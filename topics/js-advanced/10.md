# 第十课 - Promises

最后三节课会把重点放在 Promises 上面。老师一直在想该怎么教大家，看网上的文章来学习太难了，但是这个知识点又非常重要。

希望大家在学这三节课的时候是个白纸状态，这样学习的时候效果会更好。

老师以前说过，Promises 是一种解决方案，除了能解决异步处理，更多地是带给了我们一种全新的函数式编程的写法。要想写好函数式编程，应用好 Promises 就非常非常重要。

学好了之后，在写代码的时候就会达到这种状态，会无意识地设计成 Promises 的这种状态，这样才能写出高质量的代码。

如果能够将 Promises 穿插到整个项目里面，就会发现代码写起来能够这么行云流水，爽哉！

目标是什么？用更少的时间写出更高质量的代码，让自己更轻松。

## 预热

内容不一定要懂，关键的是要听懂老师的道理。阮一峰老师的文章技术性太强，可能不适合大家入门。

用在函数式编程结构中的 `function`，关键的一点：要纯。如果操作了函数体之外的内容，就会让整个函数的调用链条处于不可控的状态，同样的输入可能有不同的输入，这是不可以的。

接下来讲的，要明白**道理**。

## 开整！

如果说每个函数都是一个瓶子/容器，容器里装了一个值 `value = 1`，别的什么都没有。那么这个容器就是比较独立的一个容器。

要把这个值加 1，传统做法就是加 1 之后再把值放到容器里。如果不想干扰容器里的值，而只是把这个值运算之后得到一个新的容器，这个过程就可能会有 `function` 来干涉它。

```javascript
// 实现一个容器/类的模板
class Container {
  constructor(val) {
    this.val = val;
  }
}

// 传入一个值来初始化一个容器
var obj = new Container(1);

console.log(obj.val);
```

如果想拿上面的 `obj.val` 的值进行运算后得到一个新的值，那么就可以像下面这样来实现：

```javascript
function addOne(val) {
  return val + 1;
}

// 新容器
var obj2 = new Container(addOne(obj.val));

console.log(obj2.val);
```

这样把值从一个容器复制到新的容器中，不会影响之前的容器里的值。

但是！这样并不好，又需要 `new`，又需要定义函数，又需要一个新的 `new`，整个过程都只是 focus 在 **值** 上面了！如果需要像这样照顾整个过程的话，那函数式编程可就太麻烦了。

本质上，我只是希望拿到一个值，然后通过运算创建一个新的容器而已，我并不想去管里面的过程。

那么应该怎么改呢？我们可以在容器里做一点文章。下面在容器中构建的函数 `map()`，就是用来帮助我们用容器里的值进行计算，然后得到一个新的容器。

```javascript
class Container {
  constructor(val) {
    this.val = val;
  }

  // 映射：把函数f计算出来的新值传入 Container，来初始化一个新的容器
  map(f) {
    return new Container(f(this.val));
  }
}

// 然后就可以这么用了：先初始化第一个对象
var obj = new Container(1);

// obj.val+1 的值，作为初始值来初始化 obj2
var obj2 = obj.map(function(val) {
  return val + 1;
});

console.log(obj2.val);
```

注意：核心在于 `map`：`map` 里的 `f` 具体是什么并不重要，根据业务逻辑来灵活设计就可以了。关键是 `map` 通过一个函数对原来的值进行操作，得到了一个新的值，并用新的值初始化一个新的容器，这样不会更改原来的值。

再来看看数组的 `map` 函数：

```javascript
var list = [1, 2, 3];

var list2 = list.map(function(item) {
  return item + 1;
});
```

是不是和前面实现的 `map` 是一样的？就是如此。

得到一个新的值并不是目的，“纯”才是目的。得到一个新的值，不会改变原来的值，这样才行。

## 整个大的！

```javascript
fs.readFile('./package.json', 'utf-8',
  callback(err, result) {
    if (err) return;

    console.log(result);
});
```

这是传统的文件读取方式，在入门课中就是这样做的。

题外话：由于 `if` 里面有 `return`，因此和后面的代码只会执行其中一个，所以后面的代码不需要加 `else`。

那么讲的这些和 Promises 究竟有什么关系呢？在某种情况下，Promises 构建的就是一个独立的容器。

（听至 44 分钟处）
