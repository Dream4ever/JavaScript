# 第八课 - 停下来想一想

## 开发 WebApp 为什么要用 Express？好处是什么？

### JS 的上下文

HTML 文件在浏览器中加载完毕之后，就会执行 `script` 标签中的脚本。

而 JS 脚本在执行前和执行时，有一个“上下文”（context）的概念。可以说上下文是环境给出的可以用的一些东西。

在执行脚本之前，浏览器已经提供了一个环境，环境里面有一些对象可以操作。这些对象，就叫上下文。

JS 脚本的上下文，一部分就是浏览器提供的 window 对象。另一部分就是引入的第三方库（比如 Vue.js, Axios.js 等）。

### 回归主题

那么 Express 算不算上下文呢？要看具体环境。

比如通过 Express 初始化了一个项目，有 `router`、`views`、`models` 等等。

站在 WebApp 内部某个函数中来看的话，Express 就是这个函数的上下文。因为这个函数要正常工作，总是需要先拿一些东西的，比如需要 `req`、`res` 以及 `next`。

如果站在 WebApp 的角度来看的话，Express 就只是提供了一部分功能而已，可以理解为一组模块。

要经常这样站在各种的层次去思考同一件事情，有收获。

## package.json 在整个工程中起到了什么作用？

对 Node.js 来说，package.json 就是核心，就靠它来引入所有的第三方库。

但是这个文件只是在项目运行之前需要，要用它来检查项目的所有依赖和环境是否正常。一旦项目运行起来之后，就不再需要它了。

## Router 为什么如此重要？

Router 本身就是 Express 的一个中间件，Express 为什么把它放得如此重要？

课程一开始就讲过，WebApp 的重要功能之一就是处理路由。

为什么说它是 Express 的中间件呢？因为 `app.use('/', page);` 这种格式就是中间件的使用方式。

比如到 sample-18 的时候，page 和 api 这两个路由就已经有十多个具体的路由处理代码了，将页面路由和 API 路由分离，才更加方便，更好管理。

路由提供的各种功能，都是为了满足各种丰富的需求的。

## 数据流中为什么要传递 req、res 和 next ？

这三者贯穿了整个项目中的所有中间件，就是这三者提供了所有的能力：接收请求、返回请求、继续往流程的下一步走。

## app.js 中两个错误处理函数的作用

前一个函数接收的是剩余的路由请求。有了这个代码，才能给整个程序兜底。不过去掉这个函数的话，Express 本身也会帮忙兜底，这就是非常完善的一个设计，考虑到了各种异常情况。

很多时候学代码不是在照猫画虎，而是在学习它背后的思想。

后一个函数只有在主动执行 `next(err)` 才会执行到，它的参数也是由 `err, req, res, next` 这四个组成的。代码中的任何地方，一旦遇到了 `next(err)`，就会立刻中止后续代码的执行，跳到这个函数这里。

## 视图引擎是必须的么？

并不是。Express 可以做一个 API server，只用来返回数据。

EJS 视图引擎是 Express 支持的一种，用来实现前端页面的渲染。

在 WebApp 的角度来看，Express 和 EJS 都是第三方，它们两者可以没有任何关系。Express 中的 `app.set('view engine', ejs)` 就是用来调用各种视图引擎的。

## 构建视图

之前都讲过，这里又复习了一下。

## EJS 中 <%- %> 和 <%= %> 的差别

自己课下研究研究。

## mongodb 中的 schema 是什么意思？

要是能把 docker 搞定，那么后面解决的不只是 mongodb 的问题，而是能够解决更多的问题。

## 代码设计思想

在 `app.js` 中调用 `lib.js`，就可以执行其中的 `add()` 这个工具函数，来执行加法。

各种代码都是工具，工具有大有小，能力有大有小。

有了基础函数 `add` 之后，就可以用它来定义各种各样的函数，自增 1，自增 2，等等等等。这就是函数式变量，`inc` 系列的函数封装了过程，让这些新函数能自增指定的值。

GitHub 上的 `ramda` 这个库，本质上和课程中讲的东西是一样的，都可以通过一个公式/函数得到一个新的公式/函数。

集合 A 能够通过数学公式映射出一个唯一的结果集合 B。这个公式就可以理解为 `add` 函数，那么对这个函数进行拓展的话，就能够形成一个新的公式。

为什么要这样做？从公式映射出一个公式是很重要的一个知识点。

定义过程的目标：让开发者在做一件事的时候，尽量少地感知这个过程的存在。如果未来编程的所有工作都能实现这样的需求，那不就很简单了？我们不可能穷举出所有函数，但是如果能够有一个函数能够生成另外一个函数，这样一个创造的能力，可是有无限可能的！

如何能让一个函数只接收一个参数？这就要说说“柯里化”这个关键概念了。

```javascript
// 正常使用方式
R.add(1, 2);
// 柯里化
R.add(1)(2);
```

函数式编程的基点：希望所有的函数都只接受一个参数。

希望大家能够把这个 `add` 函数的演进方式写成一篇文章出来，去领悟这背后的思想、目的，从这个需求着手，慢慢领悟到可以用一个函数创造新的函数这种能力。

编程在本质上就是在执行运算，接收数据，进行处理，然后输出。更好的编程就是让用户不需要关注过程，传入数据，获取数据，over。

未来软件的方向：以服务的方式，提供的服务更具体化。

闭包只是函数式编程的一种方法，而函数式编程可以用来解决一些其它编程方法不能解决的问题。

第三方的库、框架都不太需要去读源码，能够通读各个常用库 & 框架的文档，亲手练一遍，就能有非常大的收获了。

老师现在开源的 community 项目，以及之后会开源的 Vue 组件化的项目，都可以当作脚手架来使用，大家可以在这个基础上去修修改改，增加自己想要的功能，做出自己的作品。

## 为什么要多个 then？

访问对象时，如果级联太深：`response.data.post._id`，中间某一级有问题，判断起来就会非常麻烦。
