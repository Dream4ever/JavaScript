# 第四节课 - 组件

## 总结

### 学习方法

- 所以说在学习技术时遇到了问题，应该尽量当场沟通、交流，这样的效率是最高的。
- 以 `v-bind:a="1"` 的例子说明，学习技术的人，他的能力就是通过不断钻研细节来提升的。

### 重要概念

- Vue 的编译器为组件添加了什么特殊功能？
- 所有的 Vue 组件同时也都是 Vue 的实例。
- **面试点**：组件中的数据对象 `data` 必须是函数，面试的时候很可能会考到。

## 开场

今天也讲不完 Vue 的内容。前面讲了四节课，每节课都讲了两个小时，一共八个小时，把大家拉进一个学习的状态。

今天讲的组件这一节全都是重点，大家可能听不懂，千万不要放弃。

就先从文档开始讲，真的是非常非常重要。能多听老师讲一点，就能有多一些收获。这样认知一点点改变之后，就会发现学习其实没什么难度。但是为什么自己学起来就这么费劲呢？是因为自己不明白这个概念是如何来的，老师在讲的过程中也会按照文档的顺序，按照示例的思考，去一步步达到我们想要的效果。

## 什么是组件

组件是 Vue 最强大的功能之一。Vue 是一个渐进式的框架，首先是一个核心库，解决的是数据与 HTML 之间绑定的问题。除此之外，Vue 还横向拓展出了组件这么一个功能。理解组件这个概念，要看你从什么视角看它。先不说 Vue 的组件，原生 HTML 中的 `div` 其实也可以看做是一个组件。而在学了 Vue 的组件之后，就会发现 HTML 的标签是一个原子化的东西，它不是我们编程的对象，而 Vue 的组件则是在它的基础之上再抽象一层出来。所以 Vue 的组件和 HTML 的“组件”完全不是一回事。

所以说：

> 组件可以扩展 HTML 元素，封装可重用的代码。

这句话可以：组件化其实是对原生 HTML 元素进行封装，来拓展元素的能力。

> 在较高层面上，组件是自定义元素，Vue 的编译器为它添加了特殊的功能。

```html
<div id="app">
  <app-nav></app-nav>
  <app-view>
    <app-sidebar></app-sidebar>
    <app-content></app-content>
  </app-view>
</div>
```

添加了什么功能，后面老师就会给我们讲。所添加的这些特殊的功能是原生 HTML 不具备的。

> 在有些情况下，组件也可以表现为用 `is` 特性进行了扩展的原生 HTML 元素。

这里给大家说个很有意思的东西：在新大的时候就有同事问我这句话该怎么理解，我看完文档之后对这句话理解了。

这里要说一句，Vue 的文档还真不是给初学者看的，大家学习的时候可能会比较辛苦。

当我们写 HTML 标签的时候，如果写一个 `xu` 标签，它不是 HTML 标签，那浏览器会怎么显示呢？我们会发现标签里的文本会正常显示。这就说明浏览器解析 HTML 的引擎是容错的，不认识的标签也没问题，里面的文本都可以正常显示。

去 W3School 上拿一份列表的代码来改改，`ul` 里面本来是 `li`，那么改成 `div` 的话，内容可以正常显示，再改成 `xu` 的话，依然可以正常显示，说明在列表中也可以写自定义标签。

再来尝试修改 `table` 这个表格标签，把里面的 `tr` 标签改成 `div`，可以正常显示，`th` 改成 `div` 也可以正常显示，部分的 `div` 再改成 `xu` 依然可以正常显示。浏览器虽然不认识自定义标签，不能显示成标准的样式，但还是可以显示里面的内容的。那么 Vue 是怎么解决自定义组件的问题呢？假设我们定义了一个 `custom` 组件，把它写成 `<tr is="custom"></tr>` 这种形式，这样一来，首先，浏览器可以正常解析 `tr` 组件/标签；其次，Vue 在浏览器解析完之后，会来个“偷天换日”，把 `tr` 组件替换成自定义的 `custom` 组件。这就是 `is` 这个用法的意义。

所以说在学习技术时遇到了问题，应该尽量当场沟通、交流，这样的效率是最高的。

> 所有的 Vue 组件同时也都是 Vue 的实例，所以可以接受相同的选项对象（除了根实例特有的选项）。

上次老师也说过，组件也是有生命周期的，也有自己的数据，和其它组件之间是隔离的（需要通信机制实现数据传递）。这个特性，其实用上面那句话就能概括了。

既然可以接受相同的选项对象，而选项对象中有锚点 `el`，有数据对象 `data` 等各种选项，那么组件也和 Vue 实例一样有这些选项。

## 全局注册

徐老师觉得“注册”这个词不是特别好，叫做“创建”更合适一些。

之前抽奖的例子就创建过组件，组件名称是一个字符串，组件选项可以包含 `props` 用于传入数据，`template` 用于设置模板。

那么什么叫全局组件？就是所有的 Vue 实例都可以访问它。这个全局组件可以放到一个独立的 JS 文件中。**但是**！全局组件**尽量不要**在实际开发中使用，它各方面都有一些问题。如果不是所有页面都需要的组件，就不要注册成全局组件。

组件注册之后，就可以作为自定义元素直接在实例的模板中使用。

## 局部注册

局部组件是通过选项对象的方式实现的。在 Vue 实例之外定义选项对象，然后在 Vue 实例中通过 `components` 选项注册组件即可。

```javascript
var Child = {
  template: '<div>A custom component!</div>'
}

new Vue({
  // ...
  components: {
    // <my-component> 将只在父组件模板中可用
    'my-component': Child,
    'my-component2': {
      template: '<div>A custom component!</div>'
    }
  }
});
```

即使写成这样也很烦人，后面会讲为什么。

## DOM 模板解析注意事项

文档中的这一部分恰恰解释了 `is` 特性，这里老师就不细说了。

什么是字符串模板？就是把 `HTML` 代码当成了字符串。而 Vue 让开发者把 HTML 拆得更碎，写到一个个组件里面，真要命！哈哈。

在老师眼里，学 HTML 根本不叫学编程，这种描述性语言其实没多大意思，CSS 也是如此。它只是给开发者带来了一堆规则，没有太多学习的魅力。那么学 JS 之后如果能控制 HTML，这样才有意思。所以 Vue 和 React 就是来解决这些问题了。

拿 Bootstrap 的一段示例 HTML 代码来说，要放到模板里面，换行的代码就必须手动拼接，真是 WTF! 既然这样，直接放到 HTML 多好？放到组件里面的话，又得拼接，又没有代码高亮，修改的时候没法自动完成，要命！

既然写这样的组件这么要命，那么有什么改进办法么？当然有了！那就是各种字符串模板：`x-template`、`.vue` 组件等，这就提供了一种新的写组件的方式，从而可以更舒服地写代码，完美！

## `data` 必须是函数

> 所有的 Vue 组件同时也都是 Vue 的实例，所以可以接受相同的选项对象（除了根实例特有的选项）。

再来回味一下上面这句话，组件和普通实例的区别就在这里：选项对象中的数据对象 `data` 必须是函数。而这个函数最终返回的必须是一个对象，也就是通过函数“中转”了一下，这样能够更好地实现组件实例之间的隔离性。

**面试点**：组件中的数据对象 `data` 必须是函数，面试的时候很可能会考到。

## 组件组合

组件里面可以套组件，它的实现也不难。后面会细说。

## 使用 Props 传递数据

往组件中传递数据的唯一方式就是通过 `props` 传值。

## 驼峰式 vs 短横线式命名

驼峰式命名是 JS 的命名习惯，短横线式则是 HTML 的命名习惯，两者各不相同，所以才会对于这一点有争执。

首先，徐老师有个结论：组件就用短横线式命名。今天是把组件当成了 HTML 的一部分，是对原子组件的再封装，那么遵循 HTML 的习惯很正常；而由于 JS 中习惯用驼峰式命名，所以才会有这种争执。

而徐老师的这个结论在一种情况下会失效：如果已经是高阶 Vue 开发者的话，就可以用驼峰式命名。在开发客户端 APP 的这个时候就已经不太关注 HTML 了，因为 HTML 已经不是开发的主要部分了，这个时候 JS 才是一等公民。所以还是那句话：要灵活。

题外话：HTML 是早于 JavaScript 的，所以不可能一开始就统一用驼峰式命名。

## 动态 Props

这个在老师更改之后的抽奖代码中有用到，传给组件的值本身就是动态的，那么组件中用到的数据也是动态的。

`v-bind` 的缩写语法其实是很方便的，因为这个指令很常用，直接用 `:` 表示就很方便了。

## 字面量语法 vs 动态语法

这是个编码规范的话题，要往组件中传递常量，这个常量应该定义在 Vue 实例的数据对象 `data` 中，而不应该直接把值在 HTML 代码中传入。

如果非要这么做，那么要尽量用 `v-bind` 语法。知道为什么嘛？这个知识点在前面也是说过的：表达式。如果写成 `a="1"`，那么传入的就是一个字符；如果是 `v-bind:a="1"`，那么传入的就是一个表达式。

这就是**细节**，学习技术的人，他的能力就是通过不断钻研细节来提升的。`Hello world` 谁都会跑，这种细节才是考验一个人的地方。

## 单向数据流

不看文档，就一句话：只允许从父组件往子组件传数据，不允许子组件往父组件传数据。为什么不允许呢？在 1.x 版本的教程中还是允许的，那个时候大家的项目写出来就乱七八糟的。如果是单向数据流，那么组件多次执行的结果就是相同的，这样就是一个**纯函数**。而使用组件的时候如果是双向数据流，那么代码就不可控了。

问题来了：如果子组件数据的变化必须要通知父组件，该怎么做呢？Vue 2.0 也提供了实现方式，这样大家虽然实现起来不方便，但是这样一来也保证了数据的变化是可控的、可跟踪的。这其实就是通过牺牲了一定的便利性，来保证了更多的可控性。

**注意**：后面在开发父子组件的时候，就要时刻注意如何保证这个数据变化是可跟踪的，如何保证数据在变化过程中出现意外的问题。

## Props 验证

通过 `v-bind` 传递给 `props` 的数据，可以在 `template` 中使用。那么实际应用时，对数据的验证是很常见的事情，Vue 就提供了丰富的验证方式。

```javascript
props: {
  user: {
    type: Object
  },
  id: {
    type: Number
  }
}
```

其实这个和函数式编程是一样的，只不过写法不太一样。

## 小结

组件部分今天就讲到这里。老师突然有个想法，现在就用学过的组件部分的知识做个栗子🌰。

## 实战

这个时候要完全跟着老师的思路走，看看老师是如何写代码的，更关键的是如何思考的。这次就做一个 todo-list。

既然是个 todo-list，那么就应该显示的像个 list 一样。前面的关注点在 HTML 和 CSS 上，先把框架搭建完毕。

先抄一个 `list-group` 过来。既然是 list，那么自然需要遍历它们：`v-for="item in tasks"`。待办事项标题就是 `item.title`，事项时间就是 `item.createAt`，事项内容就是 `item.content`，事项是否完成就是 `item.completed`。

在数据对象中自然需要一个 `tasks` 数组。为了快速构建虚拟数据，自然是需要用 `for` 循环构建出来一堆假数据。

```javascript
for (let index = 0; index < 10; index++) {
  task.push({
    title: 'task' + (i + 1),
    content: 'content' + (i + 1),
    completed: false,
    created: (new Date()).toString()
  });
}
```

数据构建出来了，浏览器中可以看到列出了一堆待办事项。接下来就继续完善布局。

`class="row justify-content-md-center"` 可以让内容居中，`class="col-md-6"` 表示内容只占 12 列的栅格系统其中的 6 列，而 `class="mt-3"` 表示元素距离上方有一定空间，也就是留白，不然顶着页面顶部就很难看。

这个时候这个 todo-list 还缺少一个完成按钮，也就是 `type=checkbox` 的 `input` 元素。那么就可以给未完成的事项加上一个 `button`，用于将当前事项标记为已完成。当然了还要给这个按钮绑定事件 `onComplete()`。

还可以给按钮加一个 CSS 属性 `float-right`，这样就把它放到右边去了。

话说，为什么老师能这么熟练，代码写起来行云流水？因为老师花时间把 Bootstrap 的官方文档看得非常熟了。把这个看熟了，以后做任何事情都是一种便利。如果不想花时间研究 CSS，那就先花一定的时间把一个 CSS 框架弄熟了，以后不就不需要花时间折腾这些事情了？就可以一门心思捣鼓 JS 了。

接下来进一步丰富功能，todo-list 中都会有未完成的事项和已完成的事项，那么就加一个按钮组，可以选择不同的按钮，来分别单独显示未完成/已完成的事项。这个按钮组也希望是动态的，那么就要用 `v-for="item in menus"`，菜单的文本就是 `menus.text`。

按钮做出来了，但是问题也来了：现在只有一个 list，而一个 list 只能显示一个东西，那么如何分别单独显示未完成/已完成呢？传统的方式就是再做两个 list 出来，一个按钮只显示 `task.completed` 为 `true` 的数据，另一个则相反。要让两个按钮使用同一个函数 `onSelected`，得先想好该如何区分。

既然按钮是个数组，那么就可以利用数组的特性。在 Vue 中，`v-for` 指令既可以遍历到数组元素，还可以遍历到数组索引：`v-for="(item, index) in menus`，而在点击按钮的时候，就要把这个 `index` 传进去：`@click="onSelected(index)"`。

知道了点击哪个按钮对应的是哪个 `index` 之后，就可以来切换 list 了。这个时候要实现切换显示的功能，还需要一个 `currentMenu` 数据对象属性，这样在切换的时候，可以对比当前的 list 和要切换的 list 是否相同，是的话就不操作，否则的话就显示另一个 list。而要筛选 list 中的事项，当然还要对每个事项加上判断：`v-if="item.completed"`。

这看着是不是很麻烦？虽然可以用 Vue 的数据绑定实现，但是在设计页面的时候还是很麻烦。而且老师的代码也有很多可以改进的地方。

比如 `v-if="currentMenu === 0"` 这种写法就很不好，因为这种硬编码（hard code）的方式很不利于功能的修改和扩展。那就看看老师是如何改进它的：

```javascript
menus: [
  {
    tag: 'completed',
    text: '完成'
  },
  {
    tag: 'working',
    text: '未完成'
  }
]
```

这里为什么要加一个 `tag` 属性呢？因为之前传入的 `index` 是不可修改的，而且也不够准确。比如把 `menus` 中两个对象的 `text` 互换一下的话，`index` 相关的代码就要对应地修改了。而 `tag` 就不会有这个问题，`tag` 为 `working` 的对象就是未完成的事项，可以随便用。

上面写出来的代码还是累一些，不过相比传统的 HTML 还是方便一点，但是代码的性能也不够好，因为两个 list 中用的都是完整的数据，这样其实没必要。

那么想要在“已完成”的 list 中只拿取 `task.completed === true`，在“未完成”的 list 中拿取另外一半的数据，该怎么改呢？这就是大家课后的作业。

老师给大家提示一下：把 `tasks` 中已完成的事项和未完成的事项分开，这样在两个 list 中用 `v-for` 遍历数据的时候就更准确了。这个数据分离的操作大家就自己写函数来实现吧。

另外，两个 list 的代码几乎是完全相同的，那么就完全可以抽离成一个组件嘛。在写这个组件 `task-item` 的 `template` 的时候，多行的字符串就不要用单引号啦，用斜撇号 `\`\`` 这个 ES6 的语法吧，很方便。

由于这个 `task-item` 是一个公共组件，`v-if` 判断语句就要去掉了，因为它会筛选掉部分数据。

这个时候问题又来了：`onComplete` 这个函数是在根实例中定义的，在组件中就没法用了。所以要把这个函数的定义从根实例中拿到组件内部来。

组件基本抽离完成了，那么如何判断要显示的是已完成的事项还是未完成的事项？可以用 `v-bind:tag="'working'"`，然后在组件中加上一个判断 `v-if="item.completed === tag"`。

这就有个坑了：`tasks` 中的 `completed` 是布尔值，而 `menus` 中的 `tag` 又是普通的字符串，这样就很难对接起来，这个时候就需要把两者统一起来，比如可以给每一个数据加个 `tag`。

题外话：在实际项目开发中，如果在数据层面就能够做好充分的设计的话，在后期编码过程中就能省掉很多问题。所以要再次强调一下良好的开发规范。

在抽离组件的时候出了一个问题：需要定义一个按钮和相关的事件。点击这个按钮触发事件的时候，和外部完全没有任何关系。那么要如何与父组件进行通信？可以通信了，才能够修改父组件中的数据，将事项标记为已完成。

小知识：下节课之前希望大家看看老师的文章：[一个简单的 JSON 存储服务](http://xugaoyang.com/post/5a6c1f298957a723cf8845e2)。

作业：

1. 老师会把代码上传，大家要去品味一下老师的做这件事情的过程，把老师的例子看懂。要知道即使有了 Vue，写代码也是很麻烦的。
2. 组件中定义的事件如何能够修改父组件中的数据？或者如何能够触发父组件中的事件？
3. 如何在组件内进行数据存储，而不是总要去操作父组件中的数据。
4. 一个大问题：上面抽离出了一个 `task-item`，而两个 `list-group` 也是很像的，如何把它俩抽离成一个 `task-list`？这个 `task-list` 的 `template` 中包含 `task-item`，这样在 HTML 页面中只引用一个 `task-list` 就能实现一个完整的 todo-list 的功能。实现了这个需求之后就可以发现，HTML 页面中其实就没东西了，开发时的焦点就完全在组件里面了，是不是清爽多了？
5. 还没完：按钮组如何封装成 `task-menu` 组件？

这样一层层抽离完毕，最后的根实例的模板中就只有组件了，是不是很爽？学好组件，不在于如何定义组件，而在于如何抽离、如何传递数据、如何处理事件，这些才是关键。

今天课上讲的例子可能会作为一个持续学习组件化的例子，所以再次强调一下，希望大家能把这个例子搞懂，并完成老师布置的几项作业。

## 文档的阅读

“使用插槽分发内容”、“动态组件”、“杂项”可以不看，“自定义事件”可以看看。

## 预告

下节课把这个例子完善了之后，就会开讲 vue-cli。当你真正进入到这个领域之后，会发现这又是一个全新的开发世界。前面铺垫了那么多知识，就是让大家逐渐进入现代化的开发方式。前面这些铺垫，有助于大家判断未来的项目应该用什么方式，两者之间的优缺点各是什么。要有这么一个效果，就需要大家把前面这四节课学过的知识都搞懂。

后面会讲 `.vue`，这就是 `vue-cli` 中写组件的方式。

写项目很有意思的地方在于如何思考、如何解决问题，这个过程是非常有意思的。
