# 第三节课 - 计算属性和观察者

## 总结

### 学习方法

- 写的例子不管有多简单，都一定要运行一下，看看代码执行结果。
- 可以用 `setTimeout()` 作为调试代码的方法。
- 代码有趣的地方在于该如何去运用它，这才是徐老师想传递给大家的一个观点。
- 看过的文字、代码，没有实际应用的话，都不能说是真的懂了。
- 代码规范非常重要。

### Vue 中的重要概念

- 如果计算属性不是对数据属性中的值进行再次加工的话，这样的计算属性就都是耍流氓。如果计算属性关联的函数不是纯函数（调用了 Vue 实例外部的变量），也是耍流氓。
- 数据属性 `message` 和计算属性 `reversedMessage` 之间只是使用和被使用的关系，不能说是绑定。因为它俩都是 Vue 实例内部的属性，像这样在同一个作用域下是可以相互关联的。而准确的“绑定”关系，是指两个原本毫无关系的内容进行了绑定。比如 Vue 实例就是通过锚点 `el` 与 HTML 中的 DOM 节点相绑定的。
- 如果计算属性的函数中还用到了全局变量，更改全局变量并不会更新计算属性的值，因为计算属性只会监听它所关联的数据属性中的值的更改。
- 想要拓展计算属性的能力的时候，就要用 `get/set`；如果只是简单地求值，那就不用了。

### 课后作业

- 阅读 MDN 和犀牛书上，关于对象属性存储器这个知识点的内容。
- 练习计算属性的 `get/set` 这个例子。
- 重点学习 Vue 文档的组件、路由这两部分。

## 开场

老师在之前的例子上做了一些改进。这说明了一件事：当我们具备了编程能力的时候，就可以用 Vue 在很短的时间内去实现各种功能。

老师从斗鱼户外直播的**女主播**身上学到了一个小技巧：把耳机的主线挂在耳朵上，让麦克风贴在嘴边，这样收音的效果会好很多。

言归正传，上次课程讲的抽奖的例子大家要尽量掌握，学着自己写一个简单的页面出来。然后可以把 UI 和逻辑都改进一下，锻炼自己优化代码的能力。

## 计算属性

这节课就专门把这部分的知识点好好地讲一讲——所以一定要抓紧学习官方文档，这样才能跟上课程的进度。

老师上节课之所以没有讲这一部分的知识，是希望大家能把这些内容多学几遍、多练几遍，这样再来听课效果才会更好。因为有了自己的实践，再听老师的课程，才能有更深刻的体会。

上节课说过了计算属性的价值：不需要在 HTML 代码中多次重复相同的内容，而这只是计算属性的价值之一。在官方文档上，计算属性描述得更简单一些，也更容易为大家所接受。老师的观点则是在官网文档的基础之上，向实际应用的方向走得更近了。

官方文档说：“如果在模板中放入太多的逻辑，会让模板过重且难以维护。”这里的“过重”，指的是代码难以阅读、难以理解。除此之外，即使模板中的逻辑比较简单，但是如果不够直接的话，也是把逻辑放在计算属性中更好一些，这一层含义就是老师所想表达的。

### 基础例子

在 `data` 中的数据属性一般就是一个值，而计算属性中一般是获取关联的函数返回值。如果只是用计算属性返回一个常量的话，这种用法其实没有什么意义，还不如直接放到数据属性中更直接。

这里有一点要注意，写的例子不管有多简单，都一定要运行一下，看看代码执行结果。

注意：如果计算属性不是对数据属性中的值进行再次加工的话，这样的计算属性就都是耍流氓。如果计算属性管理的函数不是纯函数（调用了 Vue 实例外部的变量），也是耍流氓。

另外，老师在演示代码的时候用到了 `setTimeout()` 这个方法，这也是常用的调试代码的手段之一。

题外话：老师给大家讲课，比较开心的一点就是，老师和大家的频率是一致的。如果总是在给大家讲基础，其实不太好玩，因为基础的知识学来学去就是那样。而学习新知识、运行新代码有趣的地方就在于如何去运用它，这是徐老师想传递给大家的一个观点。

### 计算属性缓存 vs 方法

徐老师觉的这一小节的标题起得并不好，其实应该叫做“计算属性 vs 方法”。

下面代码中的 `nickName` 变量其实是一个方法，在 Vue 中却把它叫做计算属性，那么究竟哪个才是对的呢？站在 JS 理念的角度来讲，Vue 的这种叫法其实是错的。但是站在对象、方法的角度来讲，这样的叫法其实是没问题的。

```javascript
computed: {
  nickName: function () {
    return 'Mr. ' + this.name;
  }
}
```

就下面两种定义函数的方法来说，第一种方法中的 `fun` 是一个函数；第二种方法中的 `fun` 则可以看做是一个变量，变量中保存的就是函数，执行结果是一样的。所以这两种叫法都是 OK 的。

```javascript
function fun() {}         // 函数语法定义法
var fun = function() {}   // 函数表达式定义法
```

那么为什么 Vue 中用的是“计算属性”这种叫法呢？

```javascript
var obj = {
  name: '',
  nickName: function () {
    return 'Mr. ' + this.name;
  }
}
```

上面的 `name` 和 `nickName` 都是对象 `obj` 中的属性，只不过一个是字符串，另一个是函数而已，所以“计算属性”这种叫法其实并没有问题。

现在回到标题上来，“计算属性 vs 方法”，是和什么方法对比的呢？是和 Vue 中的 `methods` 进行对比的。

```javascript
computed: {
  nowDate: function () {
    return Date();
  }
},
methods: {
  nowDate2: function () {
    return Date();
  }
}
```

`nowDate` 和 `nowDate2` 这两个方法，它俩的用法都不一样，那该怎么比较呢？

在模板中输出计算属性 `nowDate` 的值，不断刷新页面的话，这个值会不断更新。但是在浏览器控制台中手动设置该属性的值的话，页面中的文本并不会更新，为什么呢？其实还是之前讲过的知识：如果计算属性没有对数据属性中的值进行再次加工的话，就没有任何实用价值。这次是不是觉得老师第一次讲这个知识点的时候，自己其实并没有真正理解？换句话说，Vue 很聪明，它知道 `nowDate` 并没有和数据属性中的任何值挂钩，所以修改计算属性的值的话，并不会更新页面中显示的内容。

再说回之前官网上 `reversedMessage` 的例子，`message` 和 `reversedMessage` 哪个性能更高呢？自然是 `message`，因为 `reversedMessage` 还需要进行三次函数的计算才能得到值。

Vue 的计算属性这个概念在设计上的几个优点：

1. 如果计算属性没有和数据属性相关联（前面 `nowDate` 的例子），说明使用计算属性的方式并不符合 Vue 的设计，那我就不更新你了。
2. 如果计算属性所关联的数据属性没有变化，那 Vue 也不需要重新计算，因为计算属性对应的值也没发生变化嘛。

注意：数据属性 `message` 和计算属性 `reversedMessage` 之间只是使用和被使用的关系，不能说是绑定。因为它俩都是 Vue 实例内部的属性，所以在同一个作用域下是可以相互使用的。而准确的“绑定”关系，是指两个原本毫无关系的内容进行了绑定。比如 Vue 实例就是通过锚点 `el` 与 HTML 中的 DOM 节点相绑定。

既然计算属性关联的数据属性不变的时候，计算属性不会重新计算，那么它是如何保存计算出来的值的呢？就是利用“缓存”，把计算属性之前的值给存起来了。

而 Vue 实例的 `methods` 中的方法则是调用一次就执行一次。在调试代码的时候，用到了计算属性的地方如果发现数据没有更新，就需要检查一下计算属性部分的代码有没有写错。

注意：如果计算属性的函数中还用到了全局变量，更改全局变量并不会更新计算属性的值，因为计算属性只会监听它所关联的**数据属性**中的值的更改。

回到官网首页：再次品味一下渐进式，为什么这种方式好呢？因为它规定的规则是非常非常少的，所以相对于大型框架而言，自由度其实高了很多。然后，在使用的具体细节上，再遵循 Vue 的规范，就可以写出更好的代码了。

### 计算属性 vs 侦听属性

初始化 Vue 之后，可以通过侦听属性 `$watch` 去监听变量的变化。

```javascript
app.$watch('message', function (newValue, oldValue) {})
```

题外话，为什么侦听属性的名字叫 `$watch`，而不是 `watch`？也许是 Vue 作者喜欢呗，哈哈哈。

```javascript
var app = new Vue({
  el: '',
  data: '',
  watch: {
    // 第一种 watch
    firstName: function (val) {
      console.log('----');
    }
  }
});

app.$watch('message', function(newValue, oldValue) {
  // 第二种 watch
  console.log('====');
});
```

提示：如果有多处都需要输出日志，可以用不同的符号来进行标记，这样方便区分。

用调试代码进行测试之后，发现 `watch` 的输出在 `$watch` 之前，这是一个知识点。

那么上面的两种 watch 有什么区别呢？前面的 `watch` 传入函数的参数只有一个，而后面的 `$watch` 传入函数的参数有两个。这里徐老师用代码演示了一下，发现前面的 `watch` 其实也是可以接收两个参数的，依次为 `newValue` 和 `oldValue`，这样其实和 `$watch` 接收的参数是一样的。

这么说的话，哪种方式更好呢？有同学说前面一种方法更好，因为优先级更高。可是如果两种方式之间没有别的动作的话，那么其实哪个优先级更高是没什么关系的。

实际上，第一种 watch 相比第二种更加易读。因为前面一种方式更符合就近原则：就近定义需要用到的变量。把需要监听的变量统一放到 Vue 实例的 `watch` 属性里面，既方便管理，也方便阅读。而且还少写了一个美元符号 `$`，哈哈。

### 计算属性的 setter

这一部分是重点。经过前面的学习可以知道，在 Vue 实例内部定义的属性才能绑定到 HTML 模板中，外部定义的属性是无法绑定的（不过并不会报错）。Vue 的绑定是在其底层代码中实现的，老师之前用一个简单的例子大致演示了 Vue 是如何实现绑定的，要把属性定义在 Vue 实例内部，它才能够对属性进行封装，能够监听到属性的变化，并更新 HTML 模板。这就是 Vue 做的事情，现在来看，这件事情是不是其实并不太难？

前面所讲的其实都是计算属性的 `getter`， 而 JavaScript 对象本身就是有 `getter` 和 `setter` 的概念的。以 MDN 上的代码为例：

```javascript
var obj = {
  my_name: 'xugaoyang',

  get name() {
    console.log('get');
    console.log(this.my_name);
    return this.my_name;
  },

  set name(val) {
    console.log('set');
    this.my_name = val;
  }
}

console.log(obj.name);
```

上面的代码会输出什么？会输出两个 `xugaoyang`。如果只执行 `obj.name`，也会输出一个 `xugaoyang`。可能有同学会问，如果要获取对象的属性值，直接输出不就好了么？为什么还要用什么 `getter`？设置属性的值也是，直接赋值不就 OK 了嘛？

这个 `get/set` 其实就是个存储器，通过它可以很方便地获取或者设置值。上面代码中的 `name` 看起来像是个函数，因为后面有括号，还有代码对。但是函数名之前还有 `get/set`，而且调用它的时候还不用加括号。为什么呢？因为变量 `name` 是个存储器，而存储器都有 `get` 方法和 `set` 方法。获取值的时候，会调用 `get` 方法拿值；修改值的时候，就会调用 `set` 方法去修改值。

而 Vue 也是用了类似存储器的技术，也是在这里插入了代码，才更够更新 HTML（想起来网上说的，Vue 使用了 `Object.defineProperty` 的 `getter` 和 `setter`，所以没法用 Babel 转换成 IE9- 所支持的 JS 代码）。

问题又来了：既然有机会在这里更新 HTML，那就同时可以调用 watch 方法来通知用户了吧？是的。只要触发了 `set`，就可以执行自定义操作：更新 HTML，调用 watch 方法来通知用户。

Vue 其实只是对数据属性进行了修改：增加了 `get` 方法和 `set` 方法，这样才能够在数据属性变化之后触发对应的方法，然后才能更新 HTML，才能用 watch 方法通知用户。

现在再来看计算属性的 setter，就不会犯懵了吧？

老师前面也说过，计算属性里面其实是一个函数（函数类型的属性），但是再看 `get/set` 的示例代码的时候，发现计算属性又是一个对象，是不是又懵了？

```javascript
computed: {
  fullName: {
    get: function () {
      // return sth
    },
    set: function (newValue) {
      // do sth
    }
  }
}
```

不知道怎么用的话，老师给你一个建议：想要拓展计算属性的能力的时候，就要用 `get/set`；如果只是简单地求值，那就只写默认的 `get`。

老师在演示代码的时候，Vue 实例的名称是 `vm`，但是在浏览器中调试的时候，执行的又是 `app`，才会得不到结果。这也说明了一点：代码规范非常重要。

文档中说计算属性默认只有 `getter`，那么默认只给 `setter` 会怎么样？会没有值，因为没有给计算属性赋值，所以 `setter` 也没有意义。

看文档的时候，跟着老师的思路研究各种细节，是不是觉得写代码其实非常好玩？哈哈。

那么能不能让 `getter` 不给值呢？当然可以。比如在获取密码的时候，对于普通权限的用户，就不把密码传给他，这个时候代码就可以这么写。

### 侦听器

老师精简了官方文档上的示例。

```html
<input v-model="question">

<script>
  var app = new Vue({
    el: '',
    data: {
      question: ''
    },
    watch: {
      question: function(newValue, oldValue) {
        this.getAnswer();
      }
    },
    methods: {
      getAnswer () {
        console.log('----');
      }
    }
  })
</script>
```

HTML 中的 `input` 元素与数据属性 `question` 进行了双向绑定，在 `input` 输入文本的时候，`question` 中的值就会对应更改，而监控着该属性值的监听器就会被触发，从而调用侦听器所关联函数内的方法，比如发起网络请求，向服务器请求数据或执行其它操作。

官方文档中的示例其实是在解释侦听器的使用/业务场景，搜索有两种方式：实时搜索和非实时搜索。实时搜索就是每输入一个字符就立刻触发一次搜索，非实时搜索则与之相反。

## Class 与 Style 绑定

老师这次就给大家简单地讲讲这一小节。

拿 Bootstrap 官网的 `Button Group` 为例，把示例代码拷下来。官网的示例是三个相似的 `button`，咱们既然学了 Vue，像这种重复的工作肯定不能手动执行，那就用 `v-for` 指令遍历数据属性中的 `items` 这个对象数组。

```html
<button type="button" class="btn btn-secondary" v-for="item in items">
  {{ item.value }}
</button>

data: {
  items: [
    { value: 'button1' },
    { value: 'button2' },
    { value: 'button3' }
  ]
}
```

上面的代码很方便地就做出了三个按钮，那我们还想增加一个功能，就是点击某个按钮之后，让这个按钮变成被选中的状态，也就是以一种与其它两个按钮不同的样式呈现出来。这个需求实现起来也很简单，就是给按钮的 `click` 事件绑定一个函数，让这个函数给按钮增加一个类名就 OK 了。

```html
<button type="button"
  class="btn btn-secondary"
  v-bind:class="item.active ? 'active' : ''"
  v-for="item in items">
  {{ item.value }}
</button>

data: {
  items: [
    { value: 'button1', active: true },
    { value: 'button2', active: false }
    { value: 'button3', active: false }
  ]
}
```

这样一来，是不是觉得 Class 和 Style 绑定其实非常简单？就是这么简单。

条件渲染、列表渲染、事件处理这几部分大家下课后自己多看看，后面会讲。

## 组件

这一部分老师想了很久，决定还是下节课用一整节课的时间专门讲一讲。

## 路由

这节课最后一点时间，老师给大家讲讲路由。

之前大家学过 Express，那个框架里有路由，Vue 里面也有路由，那么这两个路由之间有什么区别？

Express 的路由是什么？每个路由都对应着一个请求（request），路由就是将请求映射到处理这个请求的函数。

在 Vue 官方文档的页面上，从首页切换到教程页面，这就是一个路由。微信中在不同的 Tab 之间切换，这是页面的切换，本质上也是路由的切换，从 A 页面切换到 B 页面的这条路径就叫路由。在 Vue 中，路由的概念就是指它对应的页面的调用方式。而 Express 中的路由则是将请求发给对应的处理函数，并返回函数的执行结果。在 Vue 中，路由对应的是一个个具体的页面，页面要被调用，就需要开放一个接口，这个接口就叫路由。

## 单页面应用释疑

既然叫单页面应用，又为什么会有那么多页面？其实一个单页面应用，在某种意义上就是一个 APP。为什么呢？这个 APP 指的是客户端 APP，而不是 WebApp，因为这个客户端 APP 的代码只运行在浏览器里面。WebApp 就不一样了，它的一部分代码运行在浏览器里面，另一部分代码则运行在服务器里面。这就是客户端 APP 和 WebApp 的不同。

为什么可以把它看做客户端 APP 呢？后面会学 Vuex，这个插件完全颠覆了前端开发的理念，开发前端页面就像是在开发 APP 一样，用的是全新的理念来开发前端页面。这个时候我们在开发的已经不是分散的页面了，而是一个工程，是一个 Application，这个 Application 下面有很多的配置，就需要用 Vuex 来管理这些配置。

注意：Vuex 并不是 Vue 的升级版，它是用来和 Vue 搭配使用，拓展 Vue 的功能而已。Vuex 是大家未来学习的方向，目前可以先不看它。

为什么要提升到客户端 APP 这个层次？开发客户端 APP，内容最终还是要从服务器获取，这件事毋庸置疑。但是如果用开发客户端 APP 的方式来开发前端页面，那就可以不从服务器拿页面，而是在客户端用数据**组装**页面，这就省掉了下载页面的时间。这种方式不就和安装 APP 一样了么？好好品味一下老师刚才的这个思考过程，这是大家后面的一个学习方向。小程序不就是这样的嘛！它用的就是这样一种方式来实现的。

## 小结

学技术就是这么好玩，总是在否定前面的概念，在不断重新定义概念，这样才能提升自己。所以一定要不断地去质疑，这是提高自己的一个很有效的方式。
