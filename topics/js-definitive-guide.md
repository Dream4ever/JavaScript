# 《JavaScript 权威指南》学习笔记

```text
是否需要重新调整为 JS 文件？各章、节、小节依次是嵌套的对象，输入章、节、小节名称，即输出该小节关键知识点。
Lexical.Charset.CaseSensitive // 输出关键知识点
```

---

# 词法结构

## 字符集

### 区分大小写

```js
var a = 0;
var A = 1;
```

### Unicode 转义序列

```js
"café" === "caf\u00e9" // => true: \u00e9 的含义见下面“字符串”一节中的“字符集和内码”这一小节
```

### 标准化

```js
"caf\u00e9".normalize() // => "café": 返回标准化的 Unicode 字符串
```

## 注释

```js
//  单行注释
/* 注释段 */ // 另一个注释段

/*
* 多行注释
*/
```

## 直接量

```js
12 // 数字
1.2 // 小数
"hello js" // 字符串
'hi' // 也是字符串
true // 布尔值
/javascript/gi // 正则表达式直接量
null // 空
[1, 2, 3] // 数组
a = { x: 1, y: 2 }; // 对象
```

## 标识符和保留字

```js
// 下面的都是合法的标识符
i
my_variable_name
v8
_dummy
$str
sí
π
```

```js
// 以下是各类保留字
break
null
/* 未来版本的 ES 中会用到 */
const
super
/* 在严格模式下是保留字 */
let
yield
arguments
eval
/* Java 的关键字 */
abstract
private
/* 全局变量和函数 */
Infinity
eval
```

## 可选的分号

```js
var a
a
=
3
console.log(a)
/* JavaScript 会识别为：var a; a = 3; console.log(a); */
```

# 类型、值和变量

对象本质上就是属性名（key）和属性值（value）之间的映射表。

```javascript
// 普通对象
Person: {
    "name": "Henry",
    "age": 28
}

// 数组对象
num = [1, 1, 2, 3, 5, 7];

// 函数对象
function add(a, b) {
    return a + b;
}
```

JavaScript 语言的核心部分还定义了三种常用的类。

```javascript
// 日期类
var date = new Date();

// 正则类
var pattern = /s$/;

// 错误类
var err = new Error();
```

JavaScript 是面向对象语言。

```js
sort(a); // 结构化编程语言，只能这样对数组排序
a.sort(); // 面向对象语言，调用数组的方法即可
```

下面是可以拥有方法的数据类型。

```javascript
// 对象类型
Person.talk()

// 数字类型
(1.23e+20).toFixed(2)

// 字符串类型
'123-234-345'.split('-')

// 布尔类型
true.toString()
```

## 数字

### 整型直接量

```javascript
0
0xff // 十六进制 <-> 255（十进制）
0377 // 八进制 <-> 255（十进制） 在ES6的严格模式下是禁止的
```

### 浮点型直接量

```javascript
3.14
.12
6.07e23
1.2E-15
```

### 算术运算

```javascript
// Math 对象的函数和常量
Math.pow(2, 53)
Math.PI
Math.random()
```

加餐：四则运算和比较。参考链接：

- [【科普向】JavaScript的四则符和比较符](https://zhuanlan.zhihu.com/p/19735745)

上溢和下溢：

```javascript
// Infinity 和 NaN: 运算出现特殊值的情况

// Infinity
1 / 0
Number.MAX_VALUE + 1E300

// -Infinity
-1 / 0
-1 / Number.MIN_VALUE

// NaN
0 / 0

// +/-0
Number.MIN_VALUE / 2 // => 0
-Number.MIN_VALUE / 2 // => -0
1 / Infinity // => 0
-1 / Infinity // => -0
```

### 二进制浮点数和四舍五入错误

```javascript
(.3 - .2) !== (.2 - .1) // => true: 因为 JS 中的浮点数只是对应实数的近似表示
```

**解决方法**：对于精度要求高的场合，可用大整数进行运算，记得保证最终值的小数点位数不要错就可以。

加餐：特殊值的判断。

```javascript
NaN != NaN // => true: 只能通过该等式或 isNaN() 函数判断是否为 NaN
isFinite(x) // 只有在参数为 NaN、Infinity 或 -Infinity 时才为 false
1 / 0 !== 1 / -0 // 只有在这个时候，0 和 -0 才不相等
```

### 日期和时间

```javascript
var then = new Date(2011, 0, 1, 17, 10, 30);
var now = new Date();
var elapsed = now - then; // 单位为毫秒
now.getFullYear() // => 2017
// 为什么月份从 0 开始，而天数从 1 开始？按欧美的星期记法，每周也是从 0，即周日开始？
// https://stackoverflow.com/a/15799570/2667665
now.getMonth() // => 8: 从 0 开始的月份，而不是从 1
now.getDate() // => 19: 从 1 开始的天数
now.getDay() // => 2: 周一至周六分别为 1~6，周日为 0
```

## 文本

### 字符集和内码

> 不影响基本使用，暂时不用深究这一部分。

JavaScript 采用 UTF-16 编码的 Unicode 字符集，每个字符均用无符号的 16 位值表示。
因为有很多符号要表示，所以 Unicode 是分区定义的，每个区也称为一个平面（plane），可存放 65536（2^16）个字符。
最前面的 65536 个字符位称为基本平面（BMP），它的码点范围为：`0 ~ 2^16 - 1`，对应的 16 进制就是 `U+0000 ~ U+FFFF`。所有最常见的字符都在这个平面，这也是 Unicode 最先定义和公布的一个平面。
剩下的字符都放在辅助平面（SMP），码点范围从 `U+010000` 开始。

```javascript
U+0000 // => null: 0000 为码点（code point），也是该字符的编号
U+597D // => '好'
```

参考资料：[Unicode与JavaScript详解](http://www.ruanyifeng.com/blog/2014/12/unicode.html)

**注意**：JavaScript 中并没有表示单个字符的“字符型”，只有字符串这一种类型。

### 字符串直接量

```javascript
"" // => 空字符串: 包含 0 个字符
'test'
"3.14"
'name="myForm"' // 由单引号定界的字符串，里面可以包含双引号，但不能再包含单引号了，否则将以内部出现的第一个单引号作为字符串的结束位置
"It\"s my life" // 由单引号/双引号定界的字符串，如果内部必须包含相同的引号，则内部包含的引号左侧一定要加上转义字符 \
"This string\n has two lines" // 字符串内可以包含换行符 \n
```

```javascript
// 在 ES5 中，下面几行字符串实际输出时只有一行，行末加反斜线是为了标记下一行还是该字符串的内容，并不是换行，\n 才是换行
"one\
long\
line"
```

### 转义字符

反斜线（\）符号后面加一个字符，该字符就不再表示它们的字面含义了。所有的转义字符及其含义如下表所示。

| 转义字符 | 含义 |
| - | - |
| `\o` | NULL字符(\u0000) |
| `\b` | 退格符(\u0008) |
| `\t` | 水平制表符(\u0009) |
| `\n` | 换行符(\u000A) |
| `\v` | 垂直制表符(\u000B) |
| `\f` | 换页符(\u000C) |
| `\r` | 回车符(\u000D) |
| `\"` | 双引号(\u0022) |
| `\'` | 撇号或单引号(\u0027) |
| `\\` | 反斜线(\u005C) |
| `\xXX` | 由两位十六进制数 XX 指定的 Latin-1 字符 |
| `\xXXXX` | 由四位十六进制数 XXXX 指定的 Unicode 字符 |

**注意**：只要反斜线（\）出现在上表中字符之外的地方，则都忽略该反斜线，比如 `\#` 和 `#` 相同。

### 字符串的使用

```javascript
msg = 'Hello' + ', ' + 'world' // 字符串直接量的拼接
greeting = msg + ' ' + name // 字符串直接量和变量的拼接
s.length // 字符串的长度
var s = 'hello, world' // 定义字符串
s.charAt(0) // => 'h': 第一个字符
s.charAt(s.length - 1) // => 'd': 最后一个字符
s.substring(1,4) // => 'ell': 游标在 1~3 之间的字符，即第 2~4 个字符
s.slice(-3) // => 'rld': 最后 3 个字符
s.indexOf('l') // => 2: 字符 l 第一次出现时的游标
s.indexOf('l', 3) // => 3: 从位置 3 开始第一次出现字符 l 的位置
s.lastIndexOf('l') // => 10: 字符 l 最后一次出现时的游标
s.split(', ') // 用 ', ' 逗号加空格将字符串分割成数组
s.replace('l', 'L') // => 'heLlo, world': 替换字符串中首个小写字符 l 为大写字符 L
s.toUpperCase() // => 'HELLO, WORLD': 字符串中所有字母变为大写
```

**注意**：前面说过，字符串是不可变类型，所以 `replace()` 和 `toUpperCase()` 这样的方法返回的是新字符串，原字符串不会发生变化，除非用 `str = str.toUpperCase()` 这样的方法对字符串进行重新赋值。

在 ES5 中，字符串可以当做只读数组，就是说可以用访问数组元素的方式来访问字符串中的单个字符：

```javascript
s = 'hello, world';
s[0] // => 'h'
s[s.length - 1] // => 'd'
```

### 模式匹配

JavaScript 定义了 `RegExp()` 构造函数，用来创建 “表示文本匹配模式” 的对象，这些模式称为 “正则表达式（regular expression）”。

RegExp 并不是 JavaScript 的基本类型，它和 Date 类型一样，只是一种具有实用 API 的特殊对象。

String 和 RegExp 对象均定义了利用正则表达式进行模式匹配和查找/替换的函数。

RegExp 也有直接量写法，可以直接在 JavaScript 程序中使用。在两条斜线 `//` 之间的文本构成了一个正则表达式直接量，第二条斜线之后还可以跟随一个或多个字母，用来修饰匹配模式的含义。

```javascript
/^HTML/ // 匹配以 HTML 开始的字符串
/[1-9][0-9]*/ // 匹配一个非零数字，后跟任意个任意数字
/\bjavascript\b/i // 匹配单词 'javascript'，忽略大小写。\b 用于匹配一个词的边界，所有非大小写罗马字母、数字或者下划线的字符，都是一个词的边界
```

RegExp 对象定义了很多有用的方法，字符串同样具有可以接收 RegExp 参数的方法。

```javascript
var text = 'testing: 1, 2, 3'; // 定义用于演示文本匹配的字符串
var pattern = /\d+/g // 匹配包含至少一个数字的实例
pattern.test(text) // => true: 匹配成功，pattern.test(text) 测试字符串 text 是否匹配 pattern 这个模式
text.search(pattern) // => 9: 首次匹配成功的字符串中第一个字符的位置，位置下标从 0 开始
text.match(pattern) // => ['1', '2', '3']: 所有匹配成功的内容组成的数组
text.replace(pattern, '#') // => 'testing: #, #, #': 将所有匹配成功的内容换成 replace() 方法中第二个参数的值
// TODO
text.split(/\D+/) // => ['', '1', '2', '3']: 为什么截取出来的数组，第一个元素是空字符串？text.match(/\D+/) 得到的结果也只是 'testing: `，并不包含后面的 `, `
```

## 布尔值

用途：通常用于 JavaScript 的控制结构中。

仅有的几个会被转换成 `false` 的假值（可用 `undefined ? true : false` 进行判断，不能用 `undefined = false` 进行判断）：

```javascript
undefined
null
0
-0
NaN
'' // 空字符串
```

### 布尔运算符

```javascript
a && b // a 和 b 均为真值时，表达式才为真
a || b // a 或 b 至少有一个为真值时，表达式就为真
```

## null 和 undefined

| null | undefined |
| - | - |
| 表示数字、字符串和对象是“无值”的。 | 表示变量没有初始化。 |
|  | 如果查询对象属性或数组元素的值时返回 undefined，就说明这个属性或者元素不存在。 |
|  | 无返回值的函数也会返回 undefined。 |
| 适合表示程序级的、正常的或在意料之中的值的空缺 | 适合表示系统级的、出乎意料的或类似错误的值的空缺 |

- 相等判断运算符 `==` 认为两者是相等的，需要用严格相等运算符 `===` 才能判断出两者是不相等的。
- 两者都不包含任何属性和方法，使用 `.` 或 `[]` 来存取他们的成员或方法时，都会产生一个类型错误：`TypeError: Cannot read property 'toString' of null/undefined`。
- 如果要赋值给变量或者属性，或者作为参数传入函数，建议用 null。

```javascript
typeof null // => 'object'
typeof undefined // => 'undefined'
```

## 全局对象

当 JavaScript 解释器启动时，或者任何 Web 浏览器加载新页面时，就会创建一个新的全局对象，并给它一组自定义的初始属性：

- 全局属性，比如 undefined、Infinity 和 NaN
- 全局函数，比如 isNan()、parseInt() 和 eval()
- 构造函数，比如 Date()、RegExp()、String()、Object() 和 Array()
- 全局对象，比如 Math 和 JSON

全局对象的初始属性并不是保留字，但应该当做保留字来对待。

在代码的最顶级，可以用 JavaScript 关键字 `this` 来引用全局对象：

```javascript
var global = this; // 定义一个引用全局对象的全局变量
```

对于客户端的 JavaScript，在其表示的浏览器窗口中的所有 JavaScript 代码中，`Window` 对象充当了全局对象。这个全局 Window 对象有一个属性 window 引用其自身，它可以代替 this 来引用全局对象。Window 对象不只是定义了核心的全局属性，还针对 Web 浏览器和客户端 JavaScript 定义了一小部分的其它全局属性。

```javascript
var global = window;
global.Infinity; // => Infinity
global.isNaN(1); // => false
global.Date(); // => "Fri Sep 22 2017 23:46:10 GMT+0800 (CST)"
global.Math.random() // => 0.26739690031767305
```

初次创建时，全局对象定义了 JavaScript 中所有的预定义全局值。用户自定义的全局值也包含在其中。如果代码中声明了一个全局变量，那么这个全局变量就是全局对象的一个属性。

## 包装对象

在 JavaScript 中，一般只有对象才有属性和/或方法（方法是不是也可以看作属性的一种？）。但为什么字符串、数字和布尔值也有属性和方法呢？

```javascript
var s = 'hello world'; // 定义字符串
var word = s.substring(s.indexOf(' ') + 1, s.length); // 使用字符串的属性
```

只要引用了字符串 s 的属性，JavaScript 就会将字符串的**值**，通过调用 new String(s) 的方式转换成对象，这个由值转换而来的对象，继承了字符串的方法，并被用来处理**属性的引用**。一旦属性引用结束，这个新创建的对象就会被销毁。

看看下面的代码，思考一下它的执行结果：

```javascript
var s = 'test'; // 创建一个字符串
s.len = 4; // 给它设置一个属性
var t = s.len; // 查询这个属性
```

运行这段代码时，最后得到的 t 的值是 undefined。为什么会这样？原因在第二行代码中。第二行代码创建了一个临时的字符串对象，并给其 len 属性赋值 4，随即就销毁了这个对象。这样一来，原始的字符串 s 其实并没有 len 这个属性。第三行代码通过原始的字符串值创建一个新字符串对象，并尝试读取其 len 属性，而这个属性其实并不存在，结果自然是 undefined 了。

上面的代码说明，在读取字符串、数字和布尔值的属性或方法时，这些类型表现的像对象一样。但不要试图给其属性赋值：修改只是发生在临时对象身上，并且这个临时对象是立即销毁的。

综上所述，存取字符串、数字或布尔值的属性时，所创建的临时对象被称作**包装对象**，它只是偶尔用来区分字符串/数字/布尔类型的值和对象的。

上面的代码隐式创建了包装对象，也可以通过 String()、Number() 或 Boolean() 构造函数来显式创建包装对象：

```javascript
var s = 'test', n = 1, b = true; // 分别创建一个字符串、数字和布尔值
var S = new String(s); // 一个字符串对象
var N = new Number(n); // 一个数值对象
var B = new Boolean(b); // 一个布尔对象
S === s; // => false: s 是一个字符串，而 S 则是一个字符串对象，注意两者的区别
```

## 不可变的原始值和可变的对象引用

### 不可变类型

JavaScript 中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）的根本区别就是：原始值是不可更改的，任何方法都无法更改/突变（mutate）一个原始值。

改变数字或者布尔值的说法本身就说不通，而对字符串来说，每次修改后的字符串就已经不是之前的字符串了。

原始值的比较是**值**的比较：只有它们的值相等时，两个原始值才相等。

```javascript
var s = 'hello'; // 定义一个字符串
s.toUpperCase(); // => 'HELLO': 虽然返回了大写的字符串，但原来的字符串 s 并没有被改变
s // => 'hello'
```

### 可变类型（对象引用）

对象和原始值不同，首先，它们是可变的——也就是说它们的值是可以修改的：

```javascript
var o = { x: 1 }; // 定义一个对象
o.x = 2; // 修改对象属性值来更改对象
o.y = 3; // 增加对象属性值来更改对象
```

### 比较两个对象

比较两个对象并不是比较他们的值，而是比较两个对象的引用。两个属性及值完全相同的对象，也是可以不相等的；各个元素完全相等的两个数组也是可以不相等的。

```javascript
var o = { x: 1 }, p = { x: 1 }; // 具有相同属性的两个对象
o === p // => false: 两个单独的对象永不相等
var a = [], b = []; // 两个单独的空数组
a === b // => false: 两个单独的数组永不相等
```

### 可变类型的复制

对象通常被称为“引用类型”，以和 JavaScript 的基本类型相区分。专业点来说就是：对象的值都是引用，比较对象就是比较引用：只有引用了同一个基对象时，两个对象才相等。

```javascript
var a = []; // 定义一个引用了空数组的变量 a
var b = a; // 变量 b 引用同一个数组
b[0] = 1; // 通过变量 b 来修改引用的数组
a[0] // => 1: 变量 a 也会被修改
a === b // => true: a 和 b 引用的是同一个数组，当然相等
```

由上面的代码可以看到，把对象赋值给变量时，只是把对象的“引用”赋值过去了，并没有把对象再复制一份。如果用这种方式把一个对象赋值给多个变量，那么任意一个变量修改了对象，其它变量都会受影响。

如果想要像不可变类型那样，每个变量都对应的是自己的“值”，就要像下面的例子一样，把对象的每个属性（数组的每个元素）显式地复制一份。

```javascript
var a = { x: 1, y: 2 }; // 待复制的对象
var b = {}; // 将要复制到的空对象
for (var i in a) { b[i] = a[i]; } // 遍历 a 并将其属性复制到 b 中

var a = ['a', 'b', 'c']; // 待复制的数组
var b = []; // 将要复制到的空目标数组
for (var i = 0; i < a.length; i++) { b[i] = a[i]; } // 遍历 a 并将其元素值复制到 b 中
```

## 类型转换

### 特殊值

以下仅列出几种特殊情况：

1. 对应的布尔值为 false 的值：undefined、null、""（空字符串）、0、-0、NaN
1. 对应的数字为 NaN 的值：undefined、"one"、['a']、function(){}（任意函数）
1. 对应的对象会抛出异常的值：undefined、null（均会 throws TypeError，比如调用 `toString()` 方法时）

参考资料：

- [对于以下现象，有没有一种通用的判断规则？](https://segmentfault.com/q/1010000010976877?)：回答中详细讲解了 JavaScript 中的类型转换。

### 显式类型转换

可以使用各种类型的构造函数进行转换。

```javascript
Number('3') // => 3
String(false) // => 'false': 使用 false.toString() 也有同样效果
Boolean([]) // => true: 空数组为 true，空对象也是如此，这是个知识点
Object(3) // => 结果等同于 new Number(3)
```

注意：只有 null 或者 undefined 没有 `toString()` 方法，其它值调用该方法的执行结果，一般和 `String()` 方法的返回结果是一样的。

对 null 和 undefined 使用 `Object()` 函数不会抛出异常，只是返回一个新建的空对象。

#### 进制转换

`toString()` 方法可以将数字转换为指定的进制。

```javascript
var n = 17;
binarl_string = n.toString(2); // => '10001'
octal_string = '0' + n.toString(8); // => '021'
hex_string = '0x' + n.toString(16); // => '0x11'
special_string = 'xx' + n.toString(7); // => 'xx23'
```

#### 设置小数点及有效数字位数

`toFixed()` 不使用科学记数法。

```javascript
var n = 123456.789;
n.toFixed(0); // => '123457'
n.toFixed(2); // => '123456.79'
n.toFixed(5); // => '123456.78900'
```

`toExponential()` 始终将数字转换为科学记数法，小数点前只有一个数字。

```javascript
n.toExponential(1); // => '1.2e+5'
n.toExponential(5); // => '1.23457e+5'
```

`toPrecision()` 则根据设置的有效位数，来决定是使用普通记数法还是科学记数法。

```javascript
n.toPrecision(4); // => '1.235e+5'
n.toPrecision(7); // => '123456.8'
n.toPrecision(10); // => '123456.7890'
```

#### 解析字符串中的数字

`Number()` 可将字符串中的数字解析成整数或浮点数直接量，但只按十进制转换，并且字符串尾部不能有非法字符——只能有数字或空格。

`parseInt()` 用于解析字符串中的数字并转换成整数，但是数字之前只能有空格或者正/负号，如果有其它字符，就都会返回 `NaN`。

```javascript
parseInt('3 a'); // => 3
parseInt('  +3'); // => 3
parseInt('0x3'); // => 3
parseInt('-3.2'); // => -3
parseInt('  -+3'); // => NaN
parseInt('.3'); // => NaN
parseInt('$3'); // => NaN
parseInt('~3'); // => NaN
parseInt('a3'); // => NaN
```

`parseInt()` 还可接收第二个参数，用于指定第一个参数的进制。如果第一个参数中的部分数字不属于第二个参数指定的进制，那么就直接忽略。

```javascript
parseInt('10', 2); // => 2
parseInt('112', 2); // => 3
parseInt('211', 2); // => NaN
parseInt('077', 8); // => 63
```

`parseFloat()` 与 `parseInt()` 类似，除了不接受用于指定进制的第二个参数之外，其它方面和 `parseInt()` 都相同。

```javascript
parseFloat('3.14 ab 2.13'); // => 3.14
parseFloat('0x112', 16); // => 0
```

### 运算符的隐式类型转换

```javascript
1 + '2' // => '12': 有字符串则转换成字符串
+'1' // => 1: 等于 Number('1')，一元 + 将操作数转换为数字
!!null // => false: 可用于特殊类型的快速判断，一元 ! 将操作数转换为布尔值并取反
```

### 对象到原始值的转换

#### 到布尔值的转换

所有的对象（数组和函数也是对象）转换为布尔值后都为 true，包装对象也是如此：`new Boolean(false)` 并不是原始值，而是一个对象，转换为布尔值后也为 true。

```javascript
Boolean({ x: 1 }) // => true
Boolean([]) // => true
Boolean(() => { console.log('123'); }) // => true
```

#### 到字符串的转换

转换规则只适用于本地对象（native object），宿主对象（如浏览器定义的对象）则根据各自规定的规则进行转换。

**注意**：对象和函数在转换成字符串的时候，要先用圆括号括起来，再调用 `toString()` 方法，数组类、正则类和日期类则不需要。当然了，如果不确定什么时候该用括号，那就一直都用括号就好了。

- 数组类返回的是用逗号分隔的各元素。
- 函数类返回的是函数定义的源码字符串。
- 正则类返回的是正则字符串直接量。
- 日期类返回的是方便阅读的日期。

```javascript
({ x: 1, y: 2}).toString() // => "[object Object]"
[1, 2, 3, 4].toString() // => "1,2,3,4"
(function f(x) { x; }).toString() // => "function f(x) { x; }"
/\d+/g.toString() // => "/\d+/g"
new Date().toString() // => "Tue Oct 10 2017 14:53:49 GMT+0800 (中国标准时间)"
```

细节探究：在 JavaScript 中，对象到字符串的转换经历了以下几个步骤：

1. 如果对象有 `toString()` 方法，就调用该方法。如果返回的是原始值并且不是字符串，则转换为字符串。然后返回字符串结果。
1. 如果对象没有 `toString()` 方法，或者该方法返回的不是原始值，则 JavaScript 就会继续调用 `valueOf()` 方法。如果对象有该方法就调用它，如果返回的是原始值并且不是字符串，则转换为字符串。然后返回字符串结果。
1. 如果以上都不满足，说明 JavaScript 无法通过 `toString()` 或者 `valueOf()` 方法获得原始值，则将抛出一个类型错误异常。

#### 到数字的转换

转换规则和到字符串的转换一样：只适用于本地对象（native object），宿主对象（如浏览器定义的对象）则根据各自规定的规则进行转换。

如果存在原始值，则默认转换为原始值。由于对象是复合值，并且大多数对象无法真正表示为一个原始值，因此默认的 `valueOf()` 方法只是简单地返回对象本身。

下面这些转换结果中，需要注意的是日期类的转换：它返回的是从 1970 年 1 月 1 日以来的毫秒数。

```javascript
({ x: 1, y: 2}).valueOf() // => {x: 1, y: 2}
[1, 2, 3, 4].valueOf() // => (4) [1, 2, 3, 4]
(function f(x) { x; }).valueOf() // => ƒ f(x) { x; }
/\d+/g.valueOf() // => /\d+/g
new Date().valueOf() // => 1507618941654
```

细节探究：在 JavaScript 中，对象到数字的转换经历了和字符串类似的几个步骤：

1. 如果对象有 `valueOf()` 方法就调用它。如果返回的是原始值并且不是数字，则转换为字符串。然后返回结果。
1. 如果对象没有 `valueOf()` 方法，或者该方法返回的不是原始值，则 JavaScript 就会继续调用 `toString()` 方法。如果对象有该方法就调用它，如果返回的是原始值并且不是数字，则转换为数字。然后返回结果。
1. 如果以上都不满足，说明 JavaScript 无法通过 `valueOf()` 或者 `toString()` 方法获得原始值，则将抛出一个类型错误异常。

上面的内容解释了空数组在参与数学运算的时候为什么会被转换为 0，以及为什么只有一个元素的数组会转换成数字。数组继承了默认的 `valueOf()` 方法，该方法返回的是对象。所以数组到数字的转换调用 `toString()` 方法，空数组被转换成空字符串，空字符串又转换成数字 0。只有一个元素的数组同理。

#### 运算符带来的转换

TODO: 这一节没太看明白。

二元 `+` 运算符的其中一个操作数为对象的话，JavaScript 将使用特殊的方法（TODO: 什么方法？）将对象转换为原始值。`==` 运算符也是如此，如果将对象和原始值比较，则会先将对象转换为原始值。

但是，如果上面所说的对象是日期类型的话就不一样了，日期类是 JavaScript 核心类型中唯一的一个预定义类型。对于日期类到字符串和数字的转换，JavaScript 都定义了有意义的实现方式。对于所有的非日期对象来说，对象到原始值的转换基本上都是对象到数字的转换（先调用 `valueOf()`），日期对象则使用对象到字符串的转换模式。但这里的转换模式还和前面所说的不太一样：`valueOf()` 或者 `toString()` 所返回的原始值不会被转换为数字或字符串，而是直接使用。

`<` 以及其它关系运算符和 `==` 一样，也会做对象到原始值的转换，但不包括日期对象：任何其它对象都会先调用 `valueOf()`，再调用 `toString()`。转换后的原始值不会被进一步转换，而是直接使用。

`+`、`==` 和 `!=` 是仅有的几个会执行字符串到原始值的转换的运算符，其他运算符到特定类型的转换都很明确，而且日期对象也没有特殊情况。比如 `-` 减号运算符就会把两个操作数都转换为数字。

```javascript
var now = new Date();
typeof(now + 1); // => "string"
typeof(now - 1); // => "number"
now == now.toString(); // => true
now > (now - 1); // => true
```

## 变量声明

JavaScript 中使用一个变量之前先声明一下是个好习惯，可以使用关键字 `var` 来声明，还可以用一个关键字声明多个变量，而且还能将编创的声明和赋值写在一起：

```javascript
var message = 'hello';
var i = 0, j = 0, k = 0;
```

如果只是声明但没有赋值，那么这个时候该变量的值就是 `undefined`。

另外，在 `for` 循环或者 `for/in` 循环内也可以用 `var` 语句来声明循环变量。

```javascript
for (var i = 0; i < 5; i++) console.log(i);
for (var p in obj) console.log(p);
```

### 变量无类型

JavaScript 中并没有规定变量始终只能为一种类型：

```javascript
var a = 1.2;
a = 'Hello';
a = [1, 2, 3];
```

### 重复/遗漏的声明

使用 `var` 重复声明变量是合法的，如果重复声明还带赋值，那就会覆盖前一次的赋值。

```javascript
var a = 1;
var a = 2;
a; // => 2
```

读取一个未声明的变量时，JavaScript 会报错。在 ES5 严格模式中，给未声明的变量赋值也会报错。虽然在非严格模式下，给未声明的变量赋值时，会给全局对象创建一个同名属性，并且工作起来似乎像一个正确声明的全局变量。但非常不建议这样写代码，所以一定要用 `var` 来声明变量。

## 变量作用域

全局变量：具有全局作用域，在 JavaScript 代码中的所有地方都有定义。

局部变量：只在所声明的函数体内有定义。函数参数也是局部变量。

优先级：在函数体内，局部变量的优先级高于同名的全局变量。

### 函数作用域与声明提前

在 JavaScript 中，虽然没有块级作用域（block scope）的概念，但是有函数作用域（function scope）：在函数体中声明的变量，在函数及内部嵌套的函数中均有定义。

```javascript
function test(o) {
    var i = 0;
    if (typeof o == 'object') {
        var j = 0;
        for (var k = 0; k < 10; k++) {}
        console.log('k1 = ' + k);
    }
    console.log('k2 = ' + k);
    console.log('j = ' + j);
}

test({});
// => k1 = 10
// => k2 = 10
// => j = 0
```

JavaScript 的函数作用域，不仅是指在函数中声明的变量，在函数及内部嵌套的函数中均有定义；而且在函数声明之前就可以被使用。这个特性称作声明提前（hoisting）。但是，只有函数的**声明**会被“提前”至函数体的顶部，赋值并不会被提前，见下面代码的执行结果。

```javascript
var scope = 'global';
function f() {
    console.log(scope);
    var scope = 'local';
    console.log(scope);
};
f();
// => undefined
// => local
```

上面的函数可以按下面的执行顺序来理解。

```javascript
function f() {
    var scope;
    console.log(scope);
    scope = 'local';
    console.log(scope);
}
```

由于 JavaScript 函数作用域的特性，同名的局部变量遮盖了全局变量。但是只有在程序执行到 var 语句的时候，局部变量才被赋值。所以在这之前就使用它的话，值自然是 `undefined`。

基于 JavaScript 的这种特性，在函数内定义变量时，可以将变量声明整体放在函数体的顶部，这样就能够清晰、准确地反映真实的变量作用域。

### 作为属性的变量

声明全局变量时，实际上是定义了全局对象的一个属性。

如果用 var 声明全局变量，则这个变量/属性是不可删除的（无法用 `delete` 运算符删除）。

如果未使用严格模式，并且直接给一个未声明的变量赋值的话（不用 var 声明），JavaScript 就会自动创建一个全部变量，并且这个变量/属性是可删除的（可以用 `delete` 运算符删除）。

```javascript
var truevar = 1;
fakevar = 2;
this.fakevar2 = 3;
console.log(delete truevar); // => false
console.log(delete fakevar); // => true
console.log(delete this.fakevar2); // => true
```

在 ES 规范中，规定全局变量是全局对象的属性。虽然对局部变量没有做类似的规定，但是可以将局部变量理解为跟函数调用相关的某个对象的属性。在 ES5 中，称作该对象为“声明上下文对象”（declarative environment record）。

JavaScript 中可以用 `this` 关键字来引用全局对象，却没有方法引用局部变量中存放的对象。这种存放局部变量对象的特有性质，是对我们不可见的内部实现。但是！可以通过闭包在局部变量的作用域之外使用它，具体请看 [MDN 上关于闭包的文档](https://github.com/Dream4ever/JavaScript/blob/master/topics/mdn-closure.md)。

### 作用域链

JavaScript 是基于词法作用域的语言：只要看看包含变量定义在内的几行源码，就能知道变量的作用域了。全局变量在程序中始终有定义，局部变量则在声明它的**整个**函数体内都有定义。

假设有一类定义了自身实现方式的对象（TODO: 没看懂 => 说的就是函数？），而我们将局部变量看作是这类对象的属性的话，我们就可以换个角度来理解变量作用域了。

每一段 JavaScript 代码（不管是全局代码还是函数）都有一个对应的作用域链（scope chain）。这个作用域链是一系列对象组成的列表（list）或者链表（chain），而这一系列对象定义了它们的“作用域”中的变量。JavaScript 在作用域链上查找变量 x 时（这个过程叫做变量解析 - variable resolution），它会从第一个对象开始，一直找到最后一个对象，如果整个作用域链上都没找到包含属性 x 的对象，就认为 x 不在这个作用域链上，并且会抛出一个引用错误（ReferenceError）的异常。

在 JavaScript 的最顶层（最外层，不在任何函数定义内）代码中，作用域链只有一个对象：就是全局对象。在不包含嵌套的函数体内，作用域链包含两个对象：第一个对象定义了这个函数的参数和函数体内的局部变量，第二个对象为全局对象。在包含嵌套的函数体内，作用域链包含至少三个函数对象。（这么一说，不包含嵌套的函数，是否也可以看作是“嵌套”在全局对象内的函数？）

在**定义**一个函数时，它会保存它的作用域链——非嵌套函数会保存定义了这个函数的参数和局部变量的对象，以及全局对象；嵌套函数则保存从当前嵌套函数直至最顶层函数的相关对象（定义了每个函数的局部变量，含参数），以及全局对象。（这里可以把这个作用域链称作“定义链”。）

当**调用**这个函数时，它会创建一个新对象来保存它的局部变量（前面说过，函数参数也是局部变量），然后把这个新对象添加到定义链上，形成一个新的、更长的作用域链，这个新的作用域链表示函数的**调用**——也就是调用链。

涉及到嵌套函数的时候就更有意思了，因为每次调用外部函数的时候，内部函数就会被重新定义一次（TODO：也没看懂 => 看后面的解释）。每次调用外部函数的时候，作用域链/调用链和前一次是不一样的，内部函数在每次重新定义的时候都会和前一次有微妙的差别——每次调用外部函数时，被重新定义的内部函数的代码虽然是不变的，但是与这段代码关联的作用域链/调用链却是变化的——因为每次调用外部函数时，外部函数都会重新创建一个新对象来保存局部变量，再将这个新对象添加定义链上——所以才说每次调用外部函数时，作用域链/调用链和前一次调用是不同的，因此内部函数也和前一次不同。（TODO: 还是没有理解透彻。）

# 表达式和运算符

表达式：JavaScript 解释器会将其计算（evaluate）出一个结果。

- 常量：最简单的一类表达式。
- 变量名：也是一种简单的表达式，它的值就是赋给变量的值。

复杂表达式：由简单表达式通过运算符（或其它符号，如数组元素访问或函数调用）组合而成。

## 原始表达式

原始表达式：最简单的表达式，也是表达式的最小单位——不再包含其它表达式。常量、直接量、关键字、变量都是原始表达式。

```javascript
1.23 // 数字直接量
'hello' // 字符串直接量
/pattern/ // 正则表达式直接量
```

一些保留字也构成原始表达式：

```javascript
true // 返回布尔值：真
false // 返回布尔值：假
null // 返回值：空
this // 返回“当前”对象
```

还有一种原始表达式就是变量：

```javascript
i // 返回变量 i 的值
undefined // undefined 是全局变量，而 null 是一个关键字，它俩是不一样的
```

## 对象和数组的初始化表达式

对象和数组的初始化表达式其实是新建的对象和数组，有时候也称作“对象直接量”和“数组直接量”。但是，它们不是原始表达式，因为它们所包含的成员或者元素都是子表达式。

```javascript
[] // 空数组
[1 + 2, 3 + 4] // 数组拥有两个元素，3 和 7
var matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]; // 嵌套表达式
```

JavaScript 对数组初始化表达式进行求值的时候，表达式中的元素表达式也会各计算一次。也就是说，数组初始化表达式每次计算的值有可能是不同的。

```javascript
var i = 0;
var a = [++i, ++i, ++i]; // [1, 2, 3]
```

数组直接量中的逗号间的元素可省略，会填充为 undefined。但是如果元素列表结尾处有一个逗号，就不会再创建一个 undefined 元素了。

```javascript
var a = [1,,,,3]; // => [1, empty × 3, 3]
var b = [1,]; // => [1]
```

对象的初始化和数组非常类似。

```javascript
var obj = { x: 1, y: 2 }; // 拥有两个属性成员的对象
var emp = {}; // 空对象
var rectangle = { upperLeft: { x: 2, y: 2 },
                  lowerRight: { x: 4, y: 5 } }; // 也可以嵌套
```

和数组一样，求对象初始化表达式的值的时候，对象表达式也会各自计算一次。

```javascript
var side = 1;
var square = { 'upperLeft': { x: p.x, y: p.y }, 'lowerRight': { x: p.x + side, y: p.y + side } };
// => { upperLeft: {x: 2.3, y: -1.2}, lowerRight: {x: 3.3, y: -0.19999999999999996} }
```

## 函数定义表达式

函数定义表达式的值是这个新定义的函数，也可以叫做函数直接量。

```javascript
var square = function(x) { return x * x; }
```

## 属性访问表达式

属性访问表达式会计算得到一个对象属性或一个数组元素的值。

```javascript
expression.identifier
expression[expression]
```

获取数组元素时只能用上面的第二种写法，而对象则两种都可以用。

```javascript
var o = { x: 1, y: { z: 3 } }; // 示例对象
var a = [o, 4, [5, 6]]; // 包含示例对象的数组
o.x // => 1: 表达式 o 的属性 x
o.y.z // => 3: 表达式 o.y 的属性 z
o["x"] // => 1: 表达式 o 的属性 x
a[1] // => 4: 表达式 a 中索引为 1 的元素
a[2]["1"] // => 6: 表达式 a[2] 中索引为 1 的元素
a[0].x // => 1: 表达式 a[0] 的属性 x
```

- 对于上面两种属性访问表达式，在 `.` 或者 `[` 之前的表达式都会首先计算。
- 如果计算结果是 null 或 undefined，表达式会抛出一个类型错误异常，因为这两个值都不能包含任何属性。
- 如果运算结果不是对象（或数组），JavaScript 会先将其转换为对象。
- 如果表达式后跟句点和标识符，则会查找标识符所指定的属性的值，并作为整个表达式的值返回。
- 如果表达式后跟一对方括号，则先计算方括号内的表达式的值**并转换为字符串**，然后查找字符串所指定的属性的值并返回。
- 如果查找的属性不存在，则整个属性访问表达式的值就是 undefined。

- 虽然用标识符访问属性的写法更简单，但这种写法只适用于属性名是合法标识符，并且已经知道属性名的情况。
- 如果属性名是保留字或者包含空格和标点符号，或者是数字（对于数组而言），就必须使用方括号。
- 属性名不是固定值而是计算得出的值，也必须用方括号。

## 调用表达式

调用表达式（invocation expression）：调用（或者执行）函数或方法的语法表示。任何一个调用表达式都包含一对圆括号和左圆括号之前的表达式。

```javascript
f(0) // f 是函数表达式，0 是参数表达式
Math.max(x, y, z) // Math.max 是函数，x、y 和 z 是参数
a.sort() // a.sort 是函数，没有参数
```

对调用表达式求值：

- 先计算函数表达式，然后计算参数表达式，得到一组参数值。
- 如果函数表达式不是一个可调用的对象，则抛出一个类型错误异常。
- 函数表达式可调用，将实参的值依次赋给形参，然后执行函数体。
- 函数使用 return 语句给出返回值的话，这个值就是整个调用表达式的值。
- 否则，调用表达式的值就是 undefined。

方法调用（method invocation）：调用表达式是属性访问表达式的情况。在方法调用中，执行函数体的时候，作为属性访问主体的对象和数组，就是其调用方法内 this 的指向。借由这种特性，在面向对象编程中，函数可以调用其宿主对象。

对于调用表达式不属于方法调用的情况，通常将全局对象作为 this 的值。但是在 ES5 严格模式中定义的函数，this 的值是 undefined 而不是全局对象。

## 对象创建表达式

对象创建表达式：创建对象并调用函数（构造函数）来初始化新对象的属性。和函数调用表达式很类似，只是多了一个关键字 `new`。

```javascript
new Object()
new Point(2, 3)
```

如果对象创建表达式不需要传入参数的话，一对空的圆括号都可以省略掉。

```javascript
new Object
new Date
```

计算对象创建表达式的值：

- 先创建一个新的空对象。
- 将参数传入指定的函数，并将新对象当作这个函数里的 this 的值，函数可以使用 this 来初始化这个新创建的对象的属性。
- 如果构造函数不返回值，那么对象创建表达式的值就是这个新创建的并且被初始化了的对象。
- 如果构造函数返回对象，那么这个返回的对象就是对象创建表达式的值，新创建的对象就被丢弃了。

## 运算符概述

绝大多数运算符都是标点符号，比如 `+` 和 `=`，只有少数是由关键字表示的，比如 `delete` 和 `instanceof`。

### 操作数的个数

JavaScript 中大部分运算符都是二元运算符（也就是有两个操作数），将两个表达式合并成一个稍微复杂一点的表达式。也有一少部分运算符是一元运算符，将一个表达式转换为另一个稍微复杂一点的表达式。唯一的一个三元运算符是条件判断运算符 `? :`，它将三个表达式合并成一个表达式。

### 操作数类型和结果类型

虽然有些运算符可以用于所有数据类型，但操作数是指定类型数据的话就更好了；并且大多数运算符返回（或计算出）的也是一个特定类型的值。比如逻辑非运算符 `!` 期望的操作数就是 `bool` 类型，如果不是，则会先将其转换为该类型。

### 左值

赋值及其它几个运算符期望的操作数是 `lval` 类型，表示该操作数（表达式）只能出现在赋值运算符的左侧。在 JavaScript 中，变量、对象属性和数组元素都是左值。

ES规范允许内置函数返回一个左值，但自定义函数则不能返回左值。（TODO: 不太懂）

### 运算符的副作用

计算简单的表达式（比如 2*3）不会影响程序的运行状态，后续执行的状态也不会受影响。但有些表达式就会对程序有影响了，比如赋值运算符：给一个变量或属性赋值的话，后续使用这个变量或属性的表达式的值都会发生变化。自增和自减运算符也是这样，因为它们包含隐式的赋值。`delete` 运算符也是如此：删除一个属性就类似于（但不等于）给这个属性赋值 `undefined`。

其它的 JavaScript 运算符都没有副作用，除了函数调用表达式和对象创建表达式：在函数体或者构造函数内部运用了这些运算符并产生了副作用的时候，就说函数调用表达式和对象创建表达式是有副作用的（TODO: 也没太看懂……）。

### 运算符优先级

属性访问表达式和调用表达式的优先级要比所有其它运算符都高：

```javascript
typeof my.functions[x](y)
```

虽然 `typeof` 是优先级最高的运算符之一，但也是在属性访问和函数调用之后执行的。

最保险的保证优先级的方法，就是用圆括号来强行指定。

注意：乘法和除法的优先级高于加法和减法，赋值运算符的优先级非常低，通常总是最后执行的。

### 运算符的结合性

结合性：多个具有同样优先级的运算符表达式中的运算顺序。比如减法运算符具有从左至右的结合性，因此下面两行代码的执行效果是一样的：

```javascript
w = x - y - z;
w = ((x - y) - z);
```

### 运算顺序

运算符的优先级和结合性规定了它们在复杂的表达式中的运算顺序，但并没有规定子表达式在计算过程中的运算顺序 —— JavaScript 总是严格按照从左至右的顺序来计算表达式。

```javascript
w = x + y * z
```

比如在上面的表达式中，先依次计算表达式 w、x、y 和 z，然后计算 `y * z`，再计算 `x + y * z`，最后将其赋值给 w 所代表的变量或属性。

给表达式添加括号可以改变乘法、加法和赋值运算等运算符的关系，但从左至右计算子表达式的顺序是不会改变的。

只有在任一表达式具有副作用而影响到其它表达式的时候，其求值顺序才会和看上去有所不同。

```javascript
var a = 1;
var b = (a++)+a;
```

上面的表达式计算顺序是这样的：

1. 先计算子表达式 b 的值；
1. 计算 a++，子表达式的计算结果为 1，但是计算完成后 a 的值已经是 2 了；
1. 计算 a，值为 2；
1. 计算 (a++)+a，值为 3；
1. 将该表达式的结果 3 赋给 b。

## 算术表达式

基本的算术运算符：*（乘法）、/（除法）、%（取余）、+（加法）和 -（减法）。

加法之外的运算符都是在必要的时候将操作数转换为数字，然后求积、商、余数和差。无法转换为数字的操作数，都转换为 NaN。如果操作数是 NaN，算术运算的结果也是 NaN。

对于 JavaScript 来说，所有的数字都是浮点数，所以除法运算的结果总是浮点型。

取余运算符不限于整数，浮点数也可以，比如 `6.5 % 2.1 === 0.2（实际输出 0.19999999999999973）`。

### `+` 运算符

该运算符既可以将两个数字相加，也可以连接两个字符串。

一般来说，优先进行字符串连接。只要其中一个操作数是字符串或者转换为字符串的对象，另外一个操作数也会转换为字符串，然后加法运算符连接这两个字符串。

只有两个操作数都不是类字符串（string-like）的时候，才会进行算术加法运算。

加法运算符的表现如下：

1. 其中一个操作数是对象的话，就会遵循对象到原始值的转换规则进行转换：日期对象通过 `toString()` 方法转换，其它对象则通过 `valueOf()` 方法转换（如果 `valueOf()` 方法返回一个原始值的话）。因为大部分对象都没有可用的 `valueOf()` 方法，所以这些对象其实还是会通过 `toString()` 方法进行转换。
1. 对象转换到原始值后，如果其中一个操作数是字符串，则另一个操作数也会转换为字符串，然后加号运算符连接这两个字符串。
1. 两个操作数都不是对象的话，就会都转换为数字（或者 NaN），然后相加。

```javascript
1 + 2 // => 3: 加法
'1' + '2' // => '12': 字符串连接
'1' + 2 // => '12': 数字转换为字符串之后连接字符串
1 + {} // => '1[object Object]': 对象转换为字符串后连接字符串
true + true // => 2: 布尔值转换为数字后做加法
2 + null // => 2: null 转换为 0 之后做加法
2 + undefined // => NaN: undefined 转换为 NaN 之后做加法
```

另外，加号运算符和数字一起使用的时候，还要注意加法的结合性对运算顺序的影响。

```javascript
1 + 2 + ' blind mice' // => '3 blind mice'
1 + (2 + 'blind mice') // => '12blind mice'
```

### 一元算术运算符

一元运算符作用于一个操作数并产生一个新值。JavaScript 中的一元运算符都有很高的优先级，并且都是右结合。一元运算符在必要的时候会将操作数转换为数字。

一元加法（+）：该运算符把操作数转换为数字或者 NaN，并返回转换后的数字。如果操作数本身就是数字的话则直接返回（该运算符并不会改变操作数的正负号）。
一元减法（-）：该运算符根据需要把操作数转换为数字，然后改变运算结果的符号。

递增（++）：运算符将操作数（变量、数组元素或对象属性）转换为数字之后加 1，并将加 1 后的数值重新赋给变量、数组元素或对象属性。该运算符的返回值依赖于它相对于操作数的位置。运算符在操作数之前时，称为“前增量”，它将操作数加一之后，返回计算后的值。而运算符在操作数之后的话，称为“后增量”运算符，它对操作数进行加一运算，但返回的是加一之前的值。

```javascript
var i = 1, j = ++i; // => i: 2, j: 2
var i = 1, j = i++; // => i: 2, j: 1
```

这里还要注意区分 `++x` 和 `x = x + 1`：`++`运算符只执行数值运算操作，而 `+` 运算符有可能执行字符串连接操作。

```javascript
var x = '1'; ++x; // => 2
var x = '1'; x = x + 1; // => '11'
```

此外，由于 JavaScript 会自动进行分号补全，所以不能在后增量运算符和操作数之间插入换行符。如果插入了换行符，JavaScript 会把操作数当作一条单独的语句，并在其之前补上一个分号。

```javascript
var x = 1;
x
++ // => x: 1
```

递减（--）：与递增运算符相同。

### 位运算符

先 pass 这一小节。

## 关系表达式

关系运算符用于测试两个值之间的关系（比如“相等”、“小于”，或者“是……的属性”），并根据关系是否存在而返回 true 或者 false。

### 相等和不等运算符

`==` 和 `===` 运算符都用于比较两个值是否相等，都允许任意类型的操作数。

`===` 也称为“严格相等运算符”，

`!=` 和 `!==` 运算符是 `==` 和 `===` 运算符的求反：如果两个值通过 `==` 或 `===` 比较的结果为 true，则 `!=` 或 `!==` 的比较结果则为 false，反之亦然。

在 JavaScript 中，比较两个对象时，比较的是引用而不是值。对象只和它本身相等，和其它任何对象都不相等：即使具有相同数量的属性、相同的属性名和值也依然是不相等的。数组也是如此。

严格相等运算符 `===` 的比较流程如下：

- 如果两个值的类型不相等，则它们不相等。
- 如果两个值都是 null 或者 undefined ，则它们不相等。
- 如果两个值都是布尔值 true 或 false，则它们相等。
- 只要有一个值是 NaN，它们就不相等：NaN 和自身也不相等。所以可以用 `x !== x` 来判断是否为 NaN。
- 如果两个值为数字且相等，则它们相等。0 和 -0 也相等。
- 如果两个值为字符串，且各个对应位上的 16 位数完全相等，则它们相等。如果它们的长度或内容不同，则不相等。具有不同编码的 16 位值的两个字符串，所显示的字符可能是一样的。JavaScript 并不对 Unicode 进行标准化的转换，所以这样的字符通过 `===` 和 `==` 的比较结果也是不相等的。（TODO: 这里需要进一步了解，貌似有个有关特殊网址的 0day 漏洞应用的就是这个知识点？）
- 如果两个引用值均指向同一个对象、数组或函数，则它们相等。如果指向的是不同的对象，肯定不相等。

相等运算符 `==` 的判断就没那么严格了，如果两个操作数类型不同，相等运算符会先转换为相同类型，再进行比较：

- 如果两个操作数类型相同，则和上文所述的严格相等的比较规则和结果一样。
- 如果两个操作数类型不相同，则依据如下规则进行转换和比较：
  - 如果一个值是 null，另一个是 undefined，则它们相等。
  - 如果一个值是数字，另一个是字符串，则先将字符串转换为数字，然后比较两个数字。
  - 如果一个值是 true，则将其转换为 1 再进行比较；为 false 的话，则转换为 0 再进行比较。
  - 如果一个值是对象，另一个值是数字或字符串，则按照对象转换为原始值的规则，先将对象转换为原始值，再进行比较。JavaScript 语言核心的内置类中，只有对象使用 `toString()` 转换，其余类都是先尝试使用 `valueOf()` 转换，再尝试使用 `toString()` 转换。非核心的对象，则通过各自定义的方法转换为原始值。
  - 其它不同类型之间的比较均不相等。

以 `'1' == true` 为例：布尔值 true 首先转换为数字 1，然后字符串 '1' 也转换为数字 1，最后两个数字 1 相等，因此比较结果为 true。

### 比较运算符

虽然比较运算符的操作数可以是任意类型，但只有数字和字符串才能真正进行比较。其它类型的操作数的转换规则如下：

- 操作数为对象，则首先尝试用 `valueOf()` 转换成一个原始值，否则再用 `toString()` 的转换结果进行比较。
- 对象转换为原始值之后，如果两个操作数都是字符串，则依照字母表的顺序对两个字符串进行比较。这里的字母表顺序，是指组成字符串的 16 位 Unicode 字符的索引顺序。
- 对象转换为原始值之后，如果至少有一个操作数不是字符串，则两个操作数都转换为数字。0 和 -0 相等，Infinity 大于任何其它数（除了自己），-Infinity 小于任何其它数（除了自己）。如果其中一个操作数是（或者转换后是）NaN，则比较结果为 false。

注意：由于 JavaScript 字符串是由 16 位整数值组成的序列，所以字符串的比较就是这些数值的比较。而 Unicode 字符编码的顺序和传统字符编码顺序不太一样，其中所有大写的 ASCII 字母都“小于”小写字母。而 `String.localCompare()` 则使用本地语言的字母表中定义的字符次序进行比较，更符合用户习惯。

另外，对于数字和字符串来说，加号运算符和比较运算符也有所不同：加号运算符更偏爱字符串，至少有一个操作数是字符串，它就会进行字符串连接操作；比较运算符则更偏爱数字，只要有一个操作数是数字，它就进行数学加法操作。

```javascript
1 + 2 // => 3
'1' + '2' // => '12'
'1' + 2 // => '12'
11 < 3 // => false
'11' < '3' // => true
'11' < 3 // => false
'one' < 3 // => false
```

最后，`<=` 和 `>=` 则判断相等的时候，只是简单的“不大于”和“不小于”，并不依赖于相等运算符和严格相等运算符的比较规则。仅有一个例外：当其中一个操作数是（或者转换后是）NaN 的时候，所有 4 个比较运算符均返回 false。
