# 一个请求对应一个路由

## npm start VS npm run start

两者其实是等价的，而工程师通常都会尽量寻找能够提高自己效率的方法，那么一些高频的操作其实就可以设置快捷键，比如 `npm start` 就等于 `npm run start`。

另外 `npm i` 也是和 `npm install` 等价的，省去额外敲 6 个字母的时间，完美！哈哈。

再以老师解决徐杰同学问题的过程为例，在帮助别人或者解决自己问题的过程中，往往能够学到新的知识，还会启发新的想法，经常这样多去思考，能够让自己更快地成长。

## 理解 Express Route

Express 的路由，可以理解为工地进货各种物料。

一车物料通过工地大门（域名/IP + 端口）进入工地之后，首先由工长 A （根目录 '/'）检查是否自己要的物料，是的话就进行自己的处理（`route/index.js`）；不是的话就由工长 B （`/posts`）检查，是的话就进行自己的处理（`route/posts.js`）；这样依次检查，最后都不符合的话，那就要进行错误处理（`app.js` 最后两个函数）。

路由是如何匹配的呢？依然以工地进料为例，各个工长都只负责一类物料，比如工长 A 只负责接收钢材，B 只负责接收水泥，等等。

在 Express.js 中，搞定了 `app.set()` 和 `app.use()`，就搞定了 Express.js 一切。

## 解读 app.js

**一句话**：app.use 会处理所有的数据，一步步往下，直到某个模块接管，最后还要有一个容错的处理。

可以删掉 app.js 中的容错处理，然后猜测 Express.js 是否也会做一个容错处理。

---

app.js 中删除掉所有路由相关的代码之后，访问根目录的话，页面会返回 `Cannot get /`，说明这是框架本身返回的。

然后开始添加一个工长 A：

```javascript
app.use('/', function(req, res, next) {
    res.send('i got it');
});
```

这样就可以访问根目录。

再添加一个工长 B：

```javascript
app.use('/posts', function(req, res, next) {
    res.send('i got it: posts');
});
```

但是这个时候，访问 `/posts'`，显示的还是根目录的页面！（待确认，这个留作作业。）

app.js 的路由设置之前的一段代码，是 Express 的中间件，作用是什么？是为了分析数据、整理数据。

这么一来，就说明 Express 处理请求是从第一个 `app.use()` 开始的。而路由设置之前的那段代码，默认匹配的是所有路由！也就是等价于 `app.use('*', logger('dev'));` 这样的代码。

为什么后面的示例，能够用 `req.body.title` 这样的数据呢？就是因为前面中间件实现的那一部分功能。

既然每次光是中间件就要执行六步处理，那很多人访问的话，会不会很慢？

为了提高工程师的开发效率，增强代码的健壮性，应该怎么做？那就要实施模块化/封装！

所以不用担心这么多中间件不会影响效率，因为所用的中间件一般都是同类最好的，效率是最高的，得到最多人的认识的，所以才会放在框架中让人用，所以不用担心增加几个中间件是否会拖慢运行速度。

另外，一个个路由是怎么接管客户端的访问呢？就是靠 **响应**。

## 解读 route/index.js

`router.get()` 方法中的 `res.render()` 这类方法（`res.send()` 等等，这个留作作业）就是处理响应用的，比如在 `route/index.js` 中，`router.get()` 方法里不做任何操作，直接 `next()` 的话，由于 `/users` 这个路由不匹配，所以会直接 404。

注意：有时候同学们会在正常的处理语句之后加上一个多余的 `next()`，这样浏览器能正常显示结果，但是后端会提示错误。要避免这种情况，**一个请求只对应一个路由！**
