# 第五课 - 实例演示组件化开发

## 总结

### 学习方法

- 老师的代码弄熟之后，去默写老师的代码，能够慢慢训练出做项目的思路。
- 初学者在理解 HTML 的时候，就照着 JS 的对象来理解就好了，各种属性就是用来存数据的。

### 本次作业

- 熟读老师的 `index2.html` 代码。
- 把老师的 index2.html 移植到新项目中。

## 开场

后面很多的课程都会围绕这个 todo-list 的例子慢慢展开。学 Vue 的时候，只是看文档会觉得自己学得还不错，再重复看的话就觉得自己没有进步，是因为没有把碎片化的知识结合到项目中来。所以学习的时候一定要通过编写项目来建立自己的知识体系。老师的课程只是起到一个穿针引线的作用，大家的重点还是要放在项目上。

老师推到网上的是 `index2.html`，这次课程会带着大家快速地过一下。

## 完善 todo-list

上节课的作业：

- 如何把 HTML 代码及对应功能抽成组件？
- 如何把事件传递给父组件？

父组件：其实就是包裹组件的最外层的 Vue 实例。组件内的事件要往外传递，这个需求是很普遍的。前面也多次强调过父组件的数据是通过 `props` 传给子组件的，那么要从组件内传到外部，就需要用另外的方法。

今天回顾代码的时候，发现 `tasks` 里面不需要 `tag` 属性，而 `menus` 里面的 `tag` 属性用布尔值就行了。

老师在代码中对 `currentMenuStatus` 进行了两次初始化，这里面并没有多余的操作， Vue 实例外部的代码是真正的初始化代码，在数据对象中只是进行定义的同时赋值而已。

个人编程习惯：不管遍历什么样的 list，都用 `items` 表示，也就是 `v-bind:items="menus"` 这种形式，始终用 `items` 表示数组，在组件内部就只需要关注 `item`。

由于组件是完全独立的，操作组件中的方法时，操作的其实是组件本身的方法。那么 `menu` 触发的事件是靠什么传递过去的呢？靠的是一个中间媒介，这个媒介也是属性。

注意老师写的 `v-on:click-select="onSelected"`，这种写法其实是 Vue 本身的原则，`click-select` 就是前面所说的中间媒介的名字，`onSelected` 则是根实例中的方法。组件中的 `props` 只接受传入的数据。在子组件中触发了事件之后，事件内部调用 `this.$emit('click-select')`，父组件监听到 `click-select`，就会执行父组件的 `onSelected` 这个方法。

整体流程就是：组件内的 `onSelected` 事件被执行，触发 `click-select`，从而执行所绑定的根实例上的 `onSelected` 事件。

编程习惯：用 `click-select` 来说明它只是事件属性/中间媒介，好的命名在编程的时候能够节约很多精力。

注意：`task-item` 是组件内嵌套的组件，要调用根实例中的方法的话，就需要两次转手了（$emit）。

再注意：老师在编程的时候，有些属于不同组件的名称是相同的，老师是故意这么写的。过多重复的名字会让初学者们觉得难以阅读，但是代码熟练之后，其实反而会故意用相同的名字，一方面同名变量会有各自的作用域，互不影响；另一方面也可以让项目的整体结构更加简单、一致。

小作业：老师上传的 `index2.html` 一定要不断去看，不断去练，这样才能真正提升自己。

注意：老师新写的 sample 中用到了 myjson，大家在写代码的时候也要把自己的数据存储起来，这样用起来会很方便。

## 分析例子

首先理解一下组件化开发带来的好处：

如果把 `task-menu` 之类的组件看成和 `div` 一样的代码的话，HTML 代码看起来就很简单了。别人写好组件的话，我们就可以直接引用然后使用，非常简单。

组件化的代码用起来非常方便，这三个组件都定义在 Vue 的全局作用域了。各组件的代码，别的地方看着还好，最恶心的就是 `template`：代码写起来还是很要命，调试起来真是头大。

还有一件事：不管代码怎么写，在 HTML 页面还是用 HTML 的习惯来写的。那么如果不把组件看成标签，只是把它看成一个类/class，如何能够操作它就像操作代码一样呢？

HTML 其实只是标记语言，不能算是一门真正的编程语言。很多人在学 HTML 的时候一直不理解一件事情：这一个个的标签要怎么保存数据呢？老师回忆了一下当时学 HTML 和 CSS 的时候，是像下面这样理解的。

```javascript
var person = {
  name: 'xiaoming',
  age: 18
}

var div = {
  id: 'x',
  class: 'yy'
}
```

是不是很像？什么是数据？对于 JS 对象，`name` 就是数据，而对于 `div` 标签，`id` 就是数据。有些数据是浏览器引擎解析的时候能用得到的，比如 `id`，比如 `class`。这样想的话，设计 HTML 标签中用的自定义属性，用来存我们需要的数据不就好了？而且 JS 拿到这些自定义属性的值就可以用了。

```html
<div id="app" class="container" z="xx">
```

虽然浏览器不识别上面的属性 `z`，但依然会原样把它放在 HTML 标签的属性中，只是没有任何显示而已。这个自定义属性可以用来存放任何编程时需要的值。

再来看 Vue：为什么它能力这么强？它其实也是在 HTML 标签中加了一堆自定义的、功能丰富的属性，然后就可以实现各种各样的功能了嘛！

所以初学者在理解 HTML 的时候，就照着 JS 的对象来理解就好了，各种属性就是用来存数据的。

回头再看 Vue 组件中的要命的 `template`，有什么方法能够解决这个问题么？

这个时候，我们就要从现有的编程方式转换到另一种编程方式，它不仅解决了 `template` 的问题，其实更多的还转变了我们的思维方式。

再看老师的例子，不管怎么写，通篇操作的都是 HTML，不是么？有时候 HTML 代码还是主要的部分。在一个大杂烩的 HTML 里面去操作，这其实是一种很不好的编程思维。

1. 需要关注各个方面，而大杂烩不是我们需要的，HTML 也不是我们需要的。
2. JS 既然这么厉害了，那我们为什么不能用 JS 去创造 HTML 呢？

如果用 JS 去创造 HTML，编程时的关注点就完全变化了，这也是为什么说 JavaScript 才是真正改变了前端的技术。这一定不是 Ruby、不是 PHP 能做得到的。因为 JS 有一个天生的特点：它本身就是为了帮助 HTML 更加丰富而存在的，而它的不断发展，使它现在可以反客为主了。

那该怎么做呢？只是用现有的 JS 语言就能实现么？是可以，但是很难。所以需要一些工具来帮我们去编译。

老师之前说过，HTML 这些标签一定会成为原子级的内容。为什么呢？因为在实际项目开发的时候，并不关心这些原子级的标签，而是会根据实际功能抽象出来的一个个组件，那么在编程的时候就完全不用关注它了。

当我们要把既有的东西变成一个“原子”的时候，我们就需要一个**编译工具**。相当于在 HTML 的基础之上开发了一套新的模式，最终把用新模式写出来的代码再编译回原子级的代码，这样才能够既方便开发者，又能够保证正常地把页面呈现给用户。

注意，这件事并不是 Vue 要做的，它最开始只是为了实现数据绑定、组件化等功能。学到这会儿可以发现我们没有使用任何的编译器（node 不算），今天的例子有代码的抽离、组件化，而写组件的时候遇到的问题很麻烦，为了解决这个问题，就有人提出了一套规则，不管用什么架构，只要遵循这套规则，就都可以把按照规则编写的代码打包成浏览器支持的内容，这就是 Webpack 所做的工作。它提出了一个新概念，来编译 Vue 的代码。

## vue-cli

vue-cli 就是 Vue 提供的一个一揽子的解决方案，是一个方便开发者的工具。

参考 [QuickStart](https://github.com/vuejs/vue-cli#quickstart) 中的指令，安装 vue-cli 然后初始化项目，初始化的时候有各种选项，比如是否要用 Babel，是用 npm 还是 yarn。初始化完成之后，看看新项目的架构，我们会发现这是一个全新的世界。

题外话：在执行指令的时候，所显示的各种信息还是可以读一读的。

看看新项目的目录结构，怎么和之前学的 WebApp 项目这么像？还有 package.json，Vue 还是里面的依赖……以前学的是假前端？？？

老徐要告诉你：在今天，不管开发的是前端项目还是后端项目，形式都差不多了。因为有了 Webpack，我们就可以像开发后端项目一样来开发前端项目。

在 `src` 目录中，看到了一个以前没见过的 `App.vue` 文件（顺便装一下扩展）。这个文件里面有 `template`，写法和之前写组件的时候一样；`script` 标签里面的内容很新鲜，这里放的像是 Node.js 的代码，因为竟然用到了 `import`！有了 `import`，就意味着开发前端项目的时候也可以无限地**模块化**了！把这个文件和我们之前写的组件的代码相对应的话，我们会发现只有一个不太理解的就是 `style`。

这件事情其实非常厉害。以前写 CSS，一般是在一个或者几个文件里面来写元素的样式。CSS 一旦引用进来，所有符合条件的标签就都能应用同一个样式了，这就滥用了。如果想让 CSS 的作用于仅限于某个组件，也就是实现 CSS 的作用域，那么就用 vue 文件中的 `style` 吧！

这些一点一滴的改变，都是在解决前端遗留的问题。因为既然 HTML 和 CSS 不可能彻头彻尾地改变，那就用 JS 来重新定义它们就好了嘛！就是用新的编译方式把自己想要实现的规则编译成浏览器能解析的规则。

## 移植示例

大家一起看看老徐怎么把前面的例子搬到这里面。vue 文件中的 CSS 可以先干掉，让文件结构尽量精简，只关注重要的部分。

仔细看 vue 文件中的 `script`，这次终于明白老师为什么喜欢用 `app` 命名 Vue 实例了：因为这里用的就是 `app` 嘛！还可以看到这里用 `import` 引入了子组件，这样就能够使用它了。

然后照着 App.vue 的结构，引入在前面的示例中写的组件，组件的写法就参考 HelloWorld.vue。组件的数据照着搬进来就行了，都是选项对象嘛。

小细节：`import` 引入组件的时候，路径要准确。可以借助 VSCode 的插件辅助编写及检查。

代码弄到最后，就已经差不多了。

再看一下终端提示的 6 个错误：第一个是组件中的数据对象 `data` 里的属性必须是函数。修复了之后，页面能显示出来了，但是没有数据。看一下浏览器控制台，报错说 axios 没有定义。那就用 `npm i --save axios` 安装库，然后用 `import` 引用，有没有觉得开发方式和以前完全不同了？

这又是一个亮点：前后端开发用的库一致了，不用区分一个库是用在前端还是后端了。

通过这个过程，老师带着大家一步步地去对比和之前的开发模式有什么区别。这样才能真正理解前后端融合的开发方式为什么这么厉害，才能理解 JavaScript 为什么这么牛X。现在只有 JS 可以通过新型的编译器来编写前端页面，其它语言统统不行。

再来带大家看一个新东西：前端页面中看源码，和之前的示例一样，说明新型的编译器可以把组件化的代码完美地编译成常规的前端代码。知道这一点就可以了。

作业：把老师的 index2.html 移植到新项目中。

## 查看编译结果

编译完成之后，查看输出日志，会看到两个在 `dist` 文件夹中的 JS 文件，其实编译好的文件都在这个文件夹中，打开 HTML 文件，会发现和之前运行的页面一模一样。

是否编译成多页面，和 Webpack 的配置有关。

## 总结

这个 vue-cli 就是大家学习的方向，不断地尝试，去改里面的代码，看项目的变化。你会发现在使用这些东西的时候，万变不离其宗的还是那些基础的知识，我们需要做的只是如何把旧的知识映射到新的知识上。

有的同学可能看不懂 `export default` 这样的代码，其实它就等于下面的代码。

```javascript
var app = new Vue({
  //
});

export default app;
```

Vue 也在考虑如何让开发者尽量少地写代码。拿上面的写法来说，就是为了让 Vue 选项对象的书写尽量简单。

最酷的地方就是在组件中可以单独引用并使用第三方库，这个库最终会被编译到某个 JS 里面，而不是像以前写前端那样，放在一个个分散的文件中。

这又回到了以前函数式编程时所思考的：我们希望所写的函数尽量单纯，这样只需要一个库的其中一个功能时，就可以用 `import` 只引用所需的这个功能。

在用全新的方式开发的时候，有一点要注意：虽然可以用 `npm i` 指令安装各种库，但是并不意味着库越多越好。因为用到的所有库都会被编译到 JS 文件中，而用户在浏览网页的时候还需要下载 JS，用到的库太多的话，用户下载 JS 就会很慢，网页浏览效果就会非常差，这是一定要注意的。
