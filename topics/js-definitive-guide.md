# 《JavaScript 权威指南》学习笔记

```text
是否需要重新调整为 JS 文件？各章、节、小节依次是嵌套的对象，输入章、节、小节名称，即输出该小节关键知识点。
Lexical.Charset.CaseSensitive // 输出关键知识点
```

---

# 词法结构

## 字符集

### 区分大小写

```js
var a = 0;
var A = 1;
```

### Unicode 转义序列

```js
"café" === "caf\u00e9" // => true: \u00e9 的含义见下面“字符串”一节中的“字符集和内码”这一小节
```

### 标准化

```js
"caf\u00e9".normalize() // => "café": 返回标准化的 Unicode 字符串
```

## 注释

```js
//  单行注释
/* 注释段 */ // 另一个注释段

/*
* 多行注释
*/
```

## 直接量

```js
12 // 数字
1.2 // 小数
"hello js" // 字符串
'hi' // 也是字符串
true // 布尔值
/javascript/gi // 正则表达式直接量
null // 空
[1, 2, 3] // 数组
a = { x: 1, y: 2 }; // 对象
```

## 标识符和保留字

```js
// 下面的都是合法的标识符
i
my_variable_name
v8
_dummy
$str
sí
π
```

```js
// 以下是各类保留字
break
null
/* 未来版本的 ES 中会用到 */
const
super
/* 在严格模式下是保留字 */
let
yield
arguments
eval
/* Java 的关键字 */
abstract
private
/* 全局变量和函数 */
Infinity
eval
```

## 可选的分号

```js
var a
a
=
3
console.log(a)
/* JavaScript 会识别为：var a; a = 3; console.log(a); */
```

# 类型、值和变量

对象本质上就是属性名（key）和属性值（value）之间的映射表。

```javascript
// 普通对象
Person: {
    "name": "Henry",
    "age": 28
}

// 数组对象
num = [1, 1, 2, 3, 5, 7];

// 函数对象
function add(a, b) {
    return a + b;
}
```

JavaScript 语言的核心部分还定义了三种常用的类。

```javascript
// 日期类
var date = new Date();

// 正则类
var pattern = /s$/;

// 错误类
var err = new Error();
```

JavaScript 是面向对象语言。

```js
sort(a); // 结构化编程语言，只能这样对数组排序
a.sort(); // 面向对象语言，调用数组的方法即可
```

下面是可以拥有方法的数据类型。

```javascript
// 对象类型
Person.talk()

// 数字类型
(1.23e+20).toFixed(2)

// 字符串类型
'123-234-345'.split('-')

// 布尔类型
true.toString()
```

## 数字

### 整型直接量

```javascript
0
0xff // 十六进制 <-> 255（十进制）
0377 // 八进制 <-> 255（十进制） 在ES6的严格模式下是禁止的
```

### 浮点型直接量

```javascript
3.14
.12
6.07e23
1.2E-15
```

### 算术运算

```javascript
// Math 对象的函数和常量
Math.pow(2, 53)
Math.PI
Math.random()
```

加餐：四则运算和比较。参考链接：

- [【科普向】JavaScript的四则符和比较符](https://zhuanlan.zhihu.com/p/19735745)

上溢和下溢：

```javascript
// Infinity 和 NaN: 运算出现特殊值的情况

// Infinity
1 / 0
Number.MAX_VALUE + 1E300

// -Infinity
-1 / 0
-1 / Number.MIN_VALUE

// NaN
0 / 0

// +/-0
Number.MIN_VALUE / 2 // => 0
-Number.MIN_VALUE / 2 // => -0
1 / Infinity // => 0
-1 / Infinity // => -0
```

### 二进制浮点数和四舍五入错误

```javascript
(.3 - .2) !== (.2 - .1) // => true: 因为 JS 中的浮点数只是对应实数的近似表示
```

**解决方法**：对于精度要求高的场合，可用大整数进行运算，记得保证最终值的小数点位数不要错就可以。

加餐：特殊值的判断。

```javascript
NaN != NaN // => true: 只能通过该等式或 isNaN() 函数判断是否为 NaN
isFinite(x) // 只有在参数为 NaN、Infinity 或 -Infinity 时才为 false
1 / 0 !== 1 / -0 // 只有在这个时候，0 和 -0 才不相等
```

### 日期和时间

```javascript
var then = new Date(2011, 0, 1, 17, 10, 30);
var now = new Date();
var elapsed = now - then; // 单位为毫秒
now.getFullYear() // => 2017
// 为什么月份从 0 开始，而天数从 1 开始？按欧美的星期记法，每周也是从 0，即周日开始？
// https://stackoverflow.com/a/15799570/2667665
now.getMonth() // => 8: 从 0 开始的月份，而不是从 1
now.getDate() // => 19: 从 1 开始的天数
now.getDay() // => 2: 周一至周六分别为 1~6，周日为 0
```

## 文本

### 字符集和内码

> 不影响基本使用，暂时不用深究这一部分。

JavaScript 采用 UTF-16 编码的 Unicode 字符集，每个字符均用无符号的 16 位值表示。
因为有很多符号要表示，所以 Unicode 是分区定义的，每个区也称为一个平面（plane），可存放 65536（2^16）个字符。
最前面的 65536 个字符位称为基本平面（BMP），它的码点范围为：`0 ~ 2^16 - 1`，对应的 16 进制就是 `U+0000 ~ U+FFFF`。所有最常见的字符都在这个平面，这也是 Unicode 最先定义和公布的一个平面。
剩下的字符都放在辅助平面（SMP），码点范围从 `U+010000` 开始。

```javascript
U+0000 // => null: 0000 为码点（code point），也是该字符的编号
U+597D // => '好'
```

参考资料：[Unicode与JavaScript详解](http://www.ruanyifeng.com/blog/2014/12/unicode.html)

**注意**：JavaScript 中并没有表示单个字符的“字符型”，只有字符串这一种类型。

### 字符串直接量

```javascript
"" // => 空字符串: 包含 0 个字符
'test'
"3.14"
'name="myForm"' // 由单引号定界的字符串，里面可以包含双引号，但不能再包含单引号了，否则将以内部出现的第一个单引号作为字符串的结束位置
"It\"s my life" // 由单引号/双引号定界的字符串，如果内部必须包含相同的引号，则内部包含的引号左侧一定要加上转义字符 \
"This string\n has two lines" // 字符串内可以包含换行符 \n
```

```javascript
// 在 ES5 中，下面几行字符串实际输出时只有一行，行末加反斜线是为了标记下一行还是该字符串的内容，并不是换行，\n 才是换行
"one\
long\
line"
```

### 转义字符

反斜线（\）符号后面加一个字符，该字符就不再表示它们的字面含义了。所有的转义字符及其含义如下表所示。

| 转义字符 | 含义 |
| - | - |
| `\o` | NULL字符(\u0000) |
| `\b` | 退格符(\u0008) |
| `\t` | 水平制表符(\u0009) |
| `\n` | 换行符(\u000A) |
| `\v` | 垂直制表符(\u000B) |
| `\f` | 换页符(\u000C) |
| `\r` | 回车符(\u000D) |
| `\"` | 双引号(\u0022) |
| `\'` | 撇号或单引号(\u0027) |
| `\\` | 反斜线(\u005C) |
| `\xXX` | 由两位十六进制数 XX 指定的 Latin-1 字符 |
| `\xXXXX` | 由四位十六进制数 XXXX 指定的 Unicode 字符 |

**注意**：只要反斜线（\）出现在上表中字符之外的地方，则都忽略该反斜线，比如 `\#` 和 `#` 相同。

### 字符串的使用

```javascript
msg = 'Hello' + ', ' + 'world' // 字符串直接量的拼接
greeting = msg + ' ' + name // 字符串直接量和变量的拼接
s.length // 字符串的长度
var s = 'hello, world' // 定义字符串
s.charAt(0) // => 'h': 第一个字符
s.charAt(s.length - 1) // => 'd': 最后一个字符
s.substring(1,4) // => 'ell': 游标在 1~3 之间的字符，即第 2~4 个字符
s.slice(-3) // => 'rld': 最后 3 个字符
s.indexOf('l') // => 2: 字符 l 第一次出现时的游标
s.indexOf('l', 3) // => 3: 从位置 3 开始第一次出现字符 l 的位置
s.lastIndexOf('l') // => 10: 字符 l 最后一次出现时的游标
s.split(', ') // 用 ', ' 逗号加空格将字符串分割成数组
s.replace('l', 'L') // => 'heLlo, world': 替换字符串中首个小写字符 l 为大写字符 L
s.toUpperCase() // => 'HELLO, WORLD': 字符串中所有字母变为大写
```

**注意**：前面说过，字符串是不可变类型，所以 `replace()` 和 `toUpperCase()` 这样的方法返回的是新字符串，原字符串不会发生变化，除非用 `str = str.toUpperCase()` 这样的方法对字符串进行重新赋值。

在 ES5 中，字符串可以当做只读数组，就是说可以用访问数组元素的方式来访问字符串中的单个字符：

```javascript
s = 'hello, world';
s[0] // => 'h'
s[s.length - 1] // => 'd'
```

### 模式匹配

JavaScript 定义了 `RegExp()` 构造函数，用来创建 “表示文本匹配模式” 的对象，这些模式称为 “正则表达式（regular expression）”。

RegExp 并不是 JavaScript 的基本类型，它和 Date 类型一样，只是一种具有实用 API 的特殊对象。

String 和 RegExp 对象均定义了利用正则表达式进行模式匹配和查找/替换的函数。

RegExp 也有直接量写法，可以直接在 JavaScript 程序中使用。在两条斜线 `//` 之间的文本构成了一个正则表达式直接量，第二条斜线之后还可以跟随一个或多个字母，用来修饰匹配模式的含义。

```javascript
/^HTML/ // 匹配以 HTML 开始的字符串
/[1-9][0-9]*/ // 匹配一个非零数字，后跟任意个任意数字
/\bjavascript\b/i // 匹配单词 'javascript'，忽略大小写。\b 用于匹配一个词的边界，所有非大小写罗马字母、数字或者下划线的字符，都是一个词的边界
```

RegExp 对象定义了很多有用的方法，字符串同样具有可以接收 RegExp 参数的方法。

```javascript
var text = 'testing: 1, 2, 3'; // 定义用于演示文本匹配的字符串
var pattern = /\d+/g // 匹配包含至少一个数字的实例
pattern.test(text) // => true: 匹配成功，pattern.test(text) 测试字符串 text 是否匹配 pattern 这个模式
text.search(pattern) // => 9: 首次匹配成功的字符串中第一个字符的位置，位置下标从 0 开始
text.match(pattern) // => ['1', '2', '3']: 所有匹配成功的内容组成的数组
text.replace(pattern, '#') // => 'testing: #, #, #': 将所有匹配成功的内容换成 replace() 方法中第二个参数的值
// TODO
text.split(/\D+/) // => ['', '1', '2', '3']: 为什么截取出来的数组，第一个元素是空字符串？text.match(/\D+/) 得到的结果也只是 'testing: `，并不包含后面的 `, `
```

## 布尔值

用途：通常用于 JavaScript 的控制结构中。

仅有的几个会被转换成 `false` 的假值（可用 `undefined ? true : false` 进行判断，不能用 `undefined == false` 进行判断）：

```javascript
undefined
null
0
-0
NaN
'' // 空字符串
```

### 布尔运算符

```javascript
a && b // a 和 b 均为真值时，表达式才为真
a || b // a 或 b 至少有一个为真值时，表达式就为真
```

## null 和 undefined

| null | undefined |
| - | - |
| 表示数字、字符串和对象是“无值”的。 | 表示变量没有初始化。 |
|  | 如果查询对象属性或数组元素的值时返回 undefined，就说明这个属性或者元素不存在。 |
|  | 无返回值的函数也会返回 undefined。 |
| 适合表示程序级的、正常的或在意料之中的值的空缺。 | 适合表示系统级的、出乎意料的或类似错误的值的空缺。 |

- 相等判断运算符 `==` 认为两者是相等的，需要用严格相等运算符 `===` 才能判断出两者是不相等的。
- 两者都不包含任何属性和方法，使用 `.` 或 `[]` 来存取他们的成员或方法时，都会产生一个类型错误：`TypeError: Cannot read property 'toString' of null/undefined`。
- 如果要赋值给变量或者属性，或者作为参数传入函数，建议用 null。

```javascript
typeof null // => 'object'
typeof undefined // => 'undefined'
```

## 全局对象

当 JavaScript 解释器启动时，或者 Web 浏览器加载新页面时，就会创建一个新的全局对象，并给它一组自定义的初始属性：

- 全局属性，比如 undefined、Infinity 和 NaN
- 全局函数，比如 isNaN()、parseInt() 和 eval()
- 构造函数，比如 Date()、RegExp()、String()、Object() 和 Array()
- 全局对象，比如 Math 和 JSON

全局对象的初始属性并不是保留字，但应该当做保留字来对待。

在代码的最顶层，可以用 JavaScript 关键字 `this` 来引用全局对象：

```javascript
var global = this; // 定义一个引用全局对象的全局变量
```

对于客户端 JavaScript，在其表示的浏览器窗口中的所有 JavaScript 代码中，`Window` 对象充当了全局对象。这个全局 Window 对象有一个属性 window 引用其自身，它可以代替 this 来引用全局对象。Window 对象不只是定义了核心的全局属性，还针对 Web 浏览器和客户端 JavaScript 定义了一小部分的其它全局属性。

```javascript
var global = window;
global.Infinity; // => Infinity
global.isNaN(1); // => false
global.Date(); // => "Fri Sep 22 2017 23:46:10 GMT+0800 (CST)"
global.Math.random() // => 0.26739690031767305
```

初次创建时，全局对象定义了 JavaScript 中所有的预定义全局值。用户自定义的全局值也包含在其中。如果代码中声明了一个全局变量，那么这个全局变量就是全局对象的一个属性。

## 包装对象

在 JavaScript 中，一般只有对象才有属性和/或方法（方法是不是也可以看作属性的一种？）。但为什么字符串、数字和布尔值也有属性和方法呢？

```javascript
var s = 'hello world'; // 定义字符串
var word = s.substring(s.indexOf(' ') + 1, s.length); // 使用字符串的属性
```

因为只要引用了字符串 s 的属性，JavaScript 就会将字符串的**值**，通过调用 new String(s) 的方式转换成对象，这个由值转换而来的对象，继承了字符串的方法，并被用来处理**属性的引用**。一旦属性引用结束，这个新创建的对象就会被销毁。

看看下面的代码，思考一下它的执行结果：

```javascript
var s = 'test'; // 创建一个字符串
s.len = 4; // 给它设置一个属性
var t = s.len; // 查询这个属性
```

运行这段代码时，最后得到的 t 的值是 undefined。为什么会这样？原因在第二行代码中。第二行代码创建了一个临时的字符串对象，并给其 len 属性赋值 4，随即就销毁了这个对象。这样一来，原始的字符串 s 其实并没有 len 这个属性。第三行代码通过原始的字符串值创建一个新字符串对象，并尝试读取其 len 属性，而这个属性其实并不存在，结果自然是 undefined 了。

上面的代码说明，在读取字符串、数字和布尔值的属性或方法时，这些类型表现的像对象一样。但不要试图给其属性赋值：修改只是发生在临时对象身上，并且这个临时对象是立即销毁的。

综上所述，存取字符串、数字或布尔值的属性时，所创建的临时对象被称作**包装对象**，它只是偶尔用来区分字符串/数字/布尔类型的值和对象的。

上面的代码隐式创建了包装对象，也可以通过 String()、Number() 或 Boolean() 构造函数来显式创建包装对象：

```javascript
var s = 'test', n = 1, b = true; // 分别创建一个字符串、数字和布尔值
var S = new String(s); // 一个字符串对象
var N = new Number(n); // 一个数值对象
var B = new Boolean(b); // 一个布尔对象
S === s; // => false: s 是一个字符串，而 S 则是一个字符串对象，注意两者的区别
```

## 不可变的原始值和可变的对象引用

### 不可变类型

JavaScript 中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）的根本区别就是：原始值是不可更改的，任何方法都无法更改/突变（mutate）一个原始值。

改变数字或者布尔值的说法本身就说不通，而对字符串来说，每次修改后的字符串就已经不是之前的字符串了。

原始值的比较是**值**的比较：只有它们的值相等时，两个原始值才相等。

```javascript
var s = 'hello'; // 定义一个字符串
s.toUpperCase(); // => 'HELLO': 虽然返回了大写的字符串，但原来的字符串 s 并没有被改变
s // => 'hello'
```

### 可变类型（对象引用）

对象和原始值不同，首先，它们是可变的——也就是说它们的值是可以修改的：

```javascript
var o = { x: 1 }; // 定义一个对象
o.x = 2; // 修改对象属性值来更改对象
o.y = 3; // 增加对象属性值来更改对象
```

### 比较两个对象

比较两个对象并不是比较他们的值，而是比较两个对象的引用。两个属性及值完全相同的对象，也是可以不相等的；各个元素完全相等的两个数组也是可以不相等的。

```javascript
var o = { x: 1 }, p = { x: 1 }; // 具有相同属性的两个对象
o === p // => false: 两个单独的对象永不相等
var a = [], b = []; // 两个单独的空数组
a === b // => false: 两个单独的数组永不相等
```

### 可变类型的复制

对象通常被称为“引用类型”，以和 JavaScript 的基本类型相区分。因为对象的值都是引用，所以比较对象就是比较引用：只有引用了同一个基对象时，两个对象才相等。

```javascript
var a = []; // 定义一个引用了空数组的变量 a
var b = a; // 变量 b 引用同一个数组
b[0] = 1; // 通过变量 b 来修改引用的数组
a[0] // => 1: 变量 a 也会被修改
a === b // => true: a 和 b 引用的是同一个数组，当然相等
```

由上面的代码可以看到，把对象赋值给变量时，只是把对象的“引用”赋值过去了，并没有把对象再复制一份。如果用这种方式把一个对象赋值给多个变量，那么任意一个变量修改了对象，其它变量都会受影响。

如果想要像不可变类型那样，每个对象变量都拥有自己的“值”，就要像下面的例子一样，把对象的每个属性（数组的每个元素）显式地复制一份。

```javascript
var a = { x: 1, y: 2 }; // 待复制的对象
var b = {}; // 将要复制到的空对象
for (var i in a) { b[i] = a[i]; } // 遍历 a 并将其属性复制到 b 中

var a = ['a', 'b', 'c']; // 待复制的数组
var b = []; // 将要复制到的空目标数组
for (var i = 0; i < a.length; i++) { b[i] = a[i]; } // 遍历 a 并将其元素值复制到 b 中
```

## 类型转换

### 特殊值

以下仅列出几种特殊情况：

1. 对应的布尔值为 false 的值：undefined、null、""（空字符串）、0、-0、NaN
1. 对应的数字为 NaN 的值：undefined、"one"、['a']、function(){}（任意函数）
1. 对应的对象会抛出异常的值：undefined、null（均会 throws TypeError，比如调用 `toString()` 方法时）

参考资料：

- [对于以下现象，有没有一种通用的判断规则？](https://segmentfault.com/q/1010000010976877?)：回答中详细讲解了 JavaScript 中的类型转换。

### 显式类型转换

可以使用各种类型的构造函数进行转换。

```javascript
Number('3') // => 3
String(false) // => 'false': 使用 false.toString() 也有同样效果
Boolean([]) // => true: 空数组为 true，空对象也是如此，这是个知识点
Object(3) // => 结果等同于 new Number(3)
```

注意：只有 null 或者 undefined 没有 `toString()` 方法，其它值调用该方法的执行结果，一般和 `String()` 方法的返回结果是一样的。

对 null 和 undefined 使用 `Object()` 函数不会抛出异常，只是返回一个新建的空对象。

#### 进制转换

`toString()` 方法可以将数字转换为指定的进制。

```javascript
var n = 17;
binarl_string = n.toString(2); // => '10001'
octal_string = '0' + n.toString(8); // => '021'
hex_string = '0x' + n.toString(16); // => '0x11'
special_string = 'xx' + n.toString(7); // => 'xx23'
```

#### 设置小数点及有效数字位数

`toFixed()` 不使用科学记数法。

```javascript
var n = 123456.789;
n.toFixed(0); // => '123457'
n.toFixed(2); // => '123456.79'
n.toFixed(5); // => '123456.78900'
```

`toExponential()` 始终将数字转换为科学记数法，小数点前只有一个数字。

```javascript
n.toExponential(1); // => '1.2e+5'
n.toExponential(5); // => '1.23457e+5'
```

`toPrecision()` 则根据设置的有效位数，来决定是使用普通记数法还是科学记数法。

```javascript
n.toPrecision(4); // => '1.235e+5'
n.toPrecision(7); // => '123456.8'
n.toPrecision(10); // => '123456.7890'
```

#### 解析字符串中的数字

`Number()` 可将字符串中的数字解析成整数或浮点数直接量，但只按十进制转换，并且字符串尾部不能有非法字符——只能有数字或空格。

`parseInt()` 用于解析字符串中的数字并转换成整数，但是数字之前只能有空格或者正/负号，如果有其它字符，就都会返回 `NaN`。

```javascript
parseInt('3 a'); // => 3
parseInt('  +3'); // => 3
parseInt('0x3'); // => 3
parseInt('-3.2'); // => -3
parseInt('  -+3'); // => NaN
parseInt('.3'); // => NaN
parseInt('$3'); // => NaN
parseInt('~3'); // => NaN
parseInt('a3'); // => NaN
```

`parseInt()` 还可接收第二个参数，用于指定第一个参数的进制。如果第一个参数中的部分数字不属于第二个参数指定的进制，那么就直接忽略。

```javascript
parseInt('10', 2); // => 2
parseInt('112', 2); // => 3
parseInt('211', 2); // => NaN
parseInt('077', 8); // => 63
```

`parseFloat()` 与 `parseInt()` 类似，除了不接受用于指定进制的第二个参数之外，其它方面和 `parseInt()` 都相同。

```javascript
parseFloat('3.14 ab 2.13'); // => 3.14
parseFloat('0x112', 16); // => 0
```

### 运算符的隐式类型转换

```javascript
1 + '2' // => '12': 有字符串则转换成字符串
+'1' // => 1: 等于 Number('1')，一元 + 将操作数转换为数字
!!null // => false: 可用于特殊类型的快速判断，一元 ! 将操作数转换为布尔值并取反
```

### 对象到原始值的转换

#### 到布尔值的转换

所有的对象（数组和函数也是对象）转换为布尔值后都为 true，包装对象也是如此：`new Boolean(false)` 并不是原始值，而是一个对象，转换为布尔值后也为 true。

```javascript
Boolean({ x: 1 }) // => true
Boolean([]) // => true
Boolean(() => { console.log('123'); }) // => true
```

#### 到字符串的转换

转换规则只适用于本地对象（native object），宿主对象（如浏览器定义的对象）则根据各自规定的规则进行转换。

**注意**：对象和函数在转换成字符串的时候，要先用圆括号括起来，再调用 `toString()` 方法，数组类、正则类和日期类则不需要。当然了，如果不确定什么时候该用括号，那就一直都用括号就好了。

- 数组类返回的是用逗号分隔的各元素。
- 函数类返回的是函数定义的源码字符串。
- 正则类返回的是正则字符串直接量。
- 日期类返回的是方便阅读的日期。

```javascript
({ x: 1, y: 2}).toString() // => "[object Object]"
[1, 2, 3, 4].toString() // => "1,2,3,4"
(function f(x) { x; }).toString() // => "function f(x) { x; }"
/\d+/g.toString() // => "/\d+/g"
new Date().toString() // => "Tue Oct 10 2017 14:53:49 GMT+0800 (中国标准时间)"
```

细节探究：在 JavaScript 中，对象到字符串的转换经历了以下几个步骤：

1. 如果对象有 `toString()` 方法，就调用该方法。如果返回的是原始值并且不是字符串，则转换为字符串。然后返回字符串结果。
1. 如果对象没有 `toString()` 方法，或者该方法返回的不是原始值，则 JavaScript 就会继续调用 `valueOf()` 方法。如果对象有该方法就调用它，如果返回的是原始值并且不是字符串，则转换为字符串。然后返回字符串结果。
1. 如果以上都不满足，说明 JavaScript 无法通过 `toString()` 或者 `valueOf()` 方法获得原始值，则将抛出一个类型错误异常。

#### 到数字的转换

转换规则和到字符串的转换一样：只适用于本地对象（native object），宿主对象（如浏览器定义的对象）则根据各自规定的规则进行转换。

如果存在原始值，则默认转换为原始值。由于对象是复合值，并且大多数对象无法真正表示为一个原始值，因此默认的 `valueOf()` 方法只是简单地返回对象本身。

下面这些转换结果中，需要注意的是日期类的转换：它返回的是从 1970 年 1 月 1 日以来的毫秒数。

```javascript
({ x: 1, y: 2}).valueOf() // => {x: 1, y: 2}
[1, 2, 3, 4].valueOf() // => (4) [1, 2, 3, 4]
(function f(x) { x; }).valueOf() // => ƒ f(x) { x; }
/\d+/g.valueOf() // => /\d+/g
new Date().valueOf() // => 1507618941654
```

细节探究：在 JavaScript 中，对象到数字的转换经历了和字符串类似的几个步骤：

1. 如果对象有 `valueOf()` 方法就调用它。如果返回的是原始值并且不是数字，则转换为字符串。然后返回结果。
1. 如果对象没有 `valueOf()` 方法，或者该方法返回的不是原始值，则 JavaScript 就会继续调用 `toString()` 方法。如果对象有该方法就调用它，如果返回的是原始值并且不是数字，则转换为数字。然后返回结果。
1. 如果以上都不满足，说明 JavaScript 无法通过 `valueOf()` 或者 `toString()` 方法获得原始值，则将抛出一个类型错误异常。

上面的内容解释了空数组在参与数学运算的时候为什么会被转换为 0，以及为什么只有一个元素的数组会转换成数字。数组继承了默认的 `valueOf()` 方法，该方法返回的是对象。所以数组到数字的转换调用 `toString()` 方法，空数组被转换成空字符串，空字符串又转换成数字 0。只有一个元素的数组同理。

#### 运算符带来的转换

TODO: 这一节没太看明白。

二元 `+` 运算符的其中一个操作数为对象的话，JavaScript 将使用特殊的方法（TODO: 什么方法？）将对象转换为原始值。`==` 运算符也是如此，如果将对象和原始值比较，则会先将对象转换为原始值。

但是，如果上面所说的对象是日期类型的话就不一样了，日期类是 JavaScript 核心类型中唯一的一个预定义类型。对于日期类到字符串和数字的转换，JavaScript 都定义了有意义的实现方式。对于所有的非日期对象来说，对象到原始值的转换基本上都是对象到数字的转换（先调用 `valueOf()`），日期对象则使用对象到字符串的转换模式。但这里的转换模式还和前面所说的不太一样：`valueOf()` 或者 `toString()` 所返回的原始值不会被转换为数字或字符串，而是直接使用。

`<` 以及其它关系运算符和 `==` 一样，也会做对象到原始值的转换，但不包括日期对象：任何其它对象都会先调用 `valueOf()`，再调用 `toString()`。转换后的原始值不会被进一步转换，而是直接使用。

`+`、`==` 和 `!=` 是仅有的几个会执行字符串到原始值的转换的运算符，其他运算符到特定类型的转换都很明确，而且日期对象也没有特殊情况。比如 `-` 减号运算符就会把两个操作数都转换为数字。

```javascript
var now = new Date();
typeof(now + 1); // => "string"
typeof(now - 1); // => "number"
now == now.toString(); // => true
now > (now - 1); // => true
```

## 变量声明

JavaScript 中使用一个变量之前先声明一下是个好习惯，使用关键字 `var` 来声明。可以用一个 `var` 关键字声明多个变量，而且还能将变量的声明和赋值写在一起：

```javascript
var message = 'hello';
var i = 0, j = 0, k = 0;
```

如果只是声明但没有赋值，那么这个时候该变量的值就是 `undefined`。

另外，在 `for` 循环或者 `for/in` 循环内也可以用 `var` 语句来声明循环变量。

```javascript
for (var i = 0; i < 5; i++) console.log(i);
for (var p in obj) console.log(p);
```

### 变量无类型

JavaScript 中并没有规定变量始终只能为一种类型：

```javascript
var a = 1.2;
a = 'Hello';
a = [1, 2, 3];
```

### 重复/遗漏的声明

使用 `var` 重复声明变量是合法的，如果重复声明还带赋值，那就会覆盖前一次的赋值。

```javascript
var a = 1;
var a = 2;
a; // => 2
```

读取一个未声明的变量时，JavaScript 会报错。在 ES5 严格模式中，给未声明的变量赋值也会报错。虽然在非严格模式下，给未声明的变量赋值时，会给全局对象创建一个同名属性，并且工作起来似乎像一个正确声明的全局变量。但非常不建议这样写代码，所以一定要用 `var` 来声明变量。

## 变量作用域

全局变量：具有全局作用域，在 JavaScript 代码中的所有地方都有定义。

局部变量：只在所声明的函数体内有定义。函数参数也是局部变量。

优先级：在函数体内，局部变量的优先级高于同名的全局变量。

### 函数作用域与声明提前

在 JavaScript 中，没有块级作用域（block scope）的概念，只有函数作用域（function scope）：在函数体中声明的变量，只在函数及其内部嵌套的函数中有定义。

```javascript
function test(o) {
    var i = 0;
    if (typeof o == 'object') {
        var j = 0;
        for (var k = 0; k < 10; k++) {}
        console.log('k1 = ' + k);
    }
    console.log('k2 = ' + k);
    console.log('j = ' + j);
}

test({});
// => k1 = 10
// => k2 = 10
// => j = 0
```

JavaScript 的函数作用域，不仅是指在函数中声明的变量，在函数及内部嵌套的函数中均有定义；而且函数里的变量在声明之前就可以被使用。这个特性称作声明提前（hoisting）。但是，只有函数的**声明**会被“提前”至函数体的顶部，赋值并不会被提前，见下面代码的执行结果。

```javascript
var scope = 'global';
function f() {
    console.log(scope);
    var scope = 'local';
    console.log(scope);
};
f();
// => undefined
// => local
```

上面的函数可以按下面的执行顺序来理解。

```javascript
function f() {
    var scope;
    console.log(scope);
    scope = 'local';
    console.log(scope);
}
```

由于 JavaScript 函数作用域的特性，同名的局部变量遮盖了全局变量。但是只有在程序执行到 var 语句的时候，局部变量才被赋值。所以在这之前就使用它的话，值自然是 `undefined`。

基于 JavaScript 的这种特性，在函数内定义变量时，可以将变量声明整体放在函数体的顶部，这样就能够清晰、准确地反映真实的变量作用域。

### 作为属性的变量

声明全局变量时，实际上是定义了全局对象的一个属性。

如果用 var 声明全局变量，则这个变量/属性是不可删除的（无法用 `delete` 运算符删除）。

如果未使用严格模式，并且直接给一个未声明的变量赋值的话（不用 var 声明），JavaScript 就会自动创建一个全部变量，并且这个变量/属性是可删除的（可以用 `delete` 运算符删除）。

```javascript
var truevar = 1;
fakevar = 2;
this.fakevar2 = 3;
console.log(delete truevar); // => false
console.log(delete fakevar); // => true
console.log(delete this.fakevar2); // => true
```

在 ES 规范中，规定全局变量是全局对象的属性。虽然对局部变量没有做类似的规定，但是可以将局部变量理解为跟函数调用相关的某个对象的属性。在 ES5 中，该对象称为“声明上下文对象”（declarative environment record）。

JavaScript 中可以用 `this` 关键字来引用全局对象，却没有方法引用局部变量中存放的对象。这种存放局部变量对象的特有性质，是对我们不可见的内部实现。但是！可以通过闭包在局部变量的作用域之外使用它，具体请看 [MDN 上关于闭包的文档](https://github.com/Dream4ever/JavaScript/blob/master/topics/mdn-closure.md)。

### 作用域链

JavaScript 是基于词法作用域的语言：只要看看包含变量定义在内的几行源码，就能知道变量的作用域了。全局变量在程序中始终有定义，局部变量则在声明它的**整个**函数体内都有定义。

假设有一类定义了自身实现方式的对象（TODO: 没看懂 => 说的就是函数？），而我们将局部变量看作是这类对象的属性的话，我们就可以换个角度来理解变量作用域了。

每一段 JavaScript 代码（不管是全局代码还是函数）都有一个对应的作用域链（scope chain）。这个作用域链是一系列对象组成的列表（list）或者链表（chain），而这一系列对象定义了它们的“作用域”中的变量。JavaScript 在作用域链上查找变量 x 时（这个过程叫做变量解析 - variable resolution），它会从第一个对象开始，一直找到最后一个对象，如果整个作用域链上都没找到包含属性 x 的对象，就认为 x 不在这个作用域链上，并且会抛出一个引用错误（ReferenceError）的异常。

在 JavaScript 的最顶层（最外层，不在任何函数定义内）代码中，作用域链只有一个对象：就是全局对象。在不包含嵌套的函数体内，作用域链包含两个对象：第一个对象定义了这个函数的参数和函数体内的局部变量，第二个对象为全局对象。在包含嵌套的函数体内，作用域链包含至少三个函数对象。（这么一说，不包含嵌套的函数，是否也可以看作是“嵌套”在全局对象内的函数？）

在**定义**一个函数时，它会保存它的作用域链——非嵌套函数会保存定义了这个函数的参数和局部变量的对象，以及全局对象；嵌套函数则保存从当前嵌套函数直至最顶层函数的相关对象（定义了每个函数的局部变量，含参数），以及全局对象。（这里可以把这个作用域链称作“定义链”。）

当**调用**这个函数时，它会创建一个新对象来保存它的局部变量（前面说过，函数参数也是局部变量），然后把这个新对象添加到定义链上，形成一个新的、更长的作用域链，这个新的作用域链表示函数的**调用**——也就是调用链。

涉及到嵌套函数的时候就更有意思了，因为每次调用外部函数的时候，内部函数就会被重新定义一次（TODO：也没看懂 => 看后面的解释）。每次调用外部函数的时候，作用域链/调用链和前一次是不一样的，内部函数在每次重新定义的时候都会和前一次有微妙的差别——每次调用外部函数时，被重新定义的内部函数的代码虽然是不变的，但是与这段代码关联的作用域链/调用链却是变化的——因为每次调用外部函数时，外部函数都会重新创建一个新对象来保存局部变量，再将这个新对象添加定义链上——所以才说每次调用外部函数时，作用域链/调用链和前一次调用是不同的，因此内部函数也和前一次不同。（TODO: 还是没有理解透彻。）

# 表达式和运算符

表达式：JavaScript 解释器会将其计算（evaluate）出一个结果。

- 常量：最简单的一类表达式。
- 变量名：也是一种简单的表达式，它的值就是赋给变量的值。

复杂表达式：由简单表达式通过运算符（或其它符号，如数组元素访问或函数调用）组合而成。

## 原始表达式

原始表达式：最简单的表达式，也是表达式的最小单位——不再包含其它表达式。常量、直接量、关键字、变量都是原始表达式。

```javascript
1.23 // 数字直接量
'hello' // 字符串直接量
/pattern/ // 正则表达式直接量
```

一些保留字也构成原始表达式：

```javascript
true // 返回布尔值：真
false // 返回布尔值：假
null // 返回值：空
this // 返回“当前”对象
```

还有一种原始表达式就是变量：

```javascript
i // 返回变量 i 的值
undefined // undefined 是全局变量，而 null 是一个关键字，它俩是不一样的
```

## 对象和数组的初始化表达式

对象和数组的初始化表达式其实是新建的对象和数组，有时候也称作“对象直接量”和“数组直接量”。但是，它们不是原始表达式，因为它们所包含的成员或者元素都是子表达式。

```javascript
[] // 空数组
[1 + 2, 3 + 4] // 数组拥有两个元素，3 和 7
var matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]; // 嵌套表达式
```

JavaScript 对数组初始化表达式进行求值的时候，表达式中的元素表达式也会各计算一次。也就是说，数组初始化表达式每次计算的值有可能是不同的。

```javascript
var i = 0;
var a = [++i, ++i, ++i]; // [1, 2, 3]
```

数组直接量中的逗号间的元素可省略，会填充为 undefined。但是如果元素列表结尾处有一个逗号，逗号后就不会再创建一个 undefined 元素了。

```javascript
var a = [1,,,,3]; // => [1, empty × 3, 3]
var b = [1,]; // => [1]
```

对象的初始化和数组非常类似。

```javascript
var obj = { x: 1, y: 2 }; // 拥有两个属性成员的对象
var emp = {}; // 空对象
var rectangle = { upperLeft: { x: 2, y: 2 },
                  lowerRight: { x: 4, y: 5 } }; // 也可以嵌套
```

和数组一样，求对象初始化表达式的值的时候，对象表达式也会各自计算一次。

```javascript
var side = 1;
var square = { 'upperLeft': { x: p.x, y: p.y }, 'lowerRight': { x: p.x + side, y: p.y + side } };
// => { upperLeft: {x: 2.3, y: -1.2}, lowerRight: {x: 3.3, y: -0.19999999999999996} }
```

## 函数定义表达式

函数定义表达式的值就是新定义的函数，也可以叫做函数直接量。

```javascript
var square = function(x) { return x * x; }
```

## 属性访问表达式

属性访问表达式会计算得到一个对象属性或一个数组元素的值。

```javascript
expression.identifier
expression[expression]
```

获取数组元素时只能用上面的第二种写法，而对象则两种都可以用。

```javascript
var o = { x: 1, y: { z: 3 } }; // 示例对象
var a = [o, 4, [5, 6]]; // 包含示例对象的数组
o.x // => 1: 表达式 o 的属性 x
o.y.z // => 3: 表达式 o.y 的属性 z
o["x"] // => 1: 表达式 o 的属性 x
a[1] // => 4: 表达式 a 中索引为 1 的元素
a[2]["1"] // => 6: 表达式 a[2] 中索引为 1 的元素
a[0].x // => 1: 表达式 a[0] 的属性 x
```

- 对于上面两种属性访问表达式，在 `.` 或者 `[` 之前的表达式都会首先计算。
- 如果计算结果是 null 或 undefined，表达式会抛出一个类型错误异常，因为这两个值都不能包含任何属性。
- 如果运算结果不是对象（或数组），JavaScript 会先将其转换为对象。
- 如果表达式后跟句点和标识符，则会查找标识符所指定的属性的值，并作为整个表达式的值返回。
- 如果表达式后跟一对方括号，则先计算方括号内的表达式的值**并转换为字符串**，然后查找字符串所指定的属性的值并返回。
- 如果查找的属性不存在，则整个属性访问表达式的值就是 undefined。

- 虽然用标识符访问属性的写法更简单，但这种写法只适用于属性名是合法标识符，并且已经知道属性名的情况。
- 如果属性名是保留字或者包含空格和标点符号，或者是数字（对于数组而言），就必须使用方括号。
- 属性名不是固定值而是计算得出的值，也必须用方括号。

## 调用表达式

调用表达式（invocation expression）：调用（或者执行）函数或方法的语法表示。任何一个调用表达式都包含一对圆括号和左圆括号之前的表达式。

```javascript
f(0) // f 是函数表达式，0 是参数表达式
Math.max(x, y, z) // Math.max 是函数，x、y 和 z 是参数
a.sort() // a.sort 是函数，没有参数
```

对调用表达式求值：

- 先计算函数表达式，然后计算参数表达式，得到一组参数值。
- 如果函数表达式不是一个可调用的对象，则抛出一个类型错误异常。
- 函数表达式可调用，将实参的值依次赋给形参，然后执行函数体。
- 函数使用 return 语句给出返回值的话，这个值就是整个调用表达式的值。
- 否则，调用表达式的值就是 undefined。

方法调用（method invocation）：调用表达式是属性访问表达式的情况。在方法调用中，执行函数体的时候，作为属性访问主体的对象和数组，就是其调用方法内 this 的指向。借由这种特性，在面向对象编程中，函数可以调用其宿主对象。

调用表达式不属于方法调用时，通常将全局对象作为 this 的值。但是，在 ES5 严格模式中定义的函数，this 的值就是 undefined，而不是全局对象了。

## 对象创建表达式

对象创建表达式：创建对象并调用函数（构造函数）来初始化新对象的属性。和函数调用表达式很类似，只是多了一个**必需的**关键字 `new`。

```javascript
new Object()
new Point(2, 3)
```

如果对象创建表达式不需要传入参数的话，一对空的圆括号都可以省略掉。

```javascript
new Object
new Date
```

计算对象创建表达式的值：

- 先创建一个新的空对象。
- 将参数传入指定的函数，并将新对象当作这个函数里的 this 的值，函数可以使用 this 来初始化这个新创建的对象的属性。
- 如果构造函数不返回值，那么对象创建表达式的值就是这个新创建的并且被初始化了的对象。
- 如果构造函数返回对象，那么这个返回的对象就是对象创建表达式的值，新创建的对象就被丢弃了。

## 运算符概述

绝大多数运算符都是标点符号，比如 `+` 和 `=`，只有少数是由关键字表示的，比如 `delete` 和 `instanceof`。

### 操作数的个数

JavaScript 中大部分运算符都是二元运算符（也就是有两个操作数），将两个表达式合并成一个稍微复杂一点的表达式。也有一少部分运算符是一元运算符，将一个表达式转换为另一个稍微复杂一点的表达式。唯一的一个三元运算符是条件判断运算符 `? :`，它将三个表达式合并成一个表达式。

### 操作数类型和结果类型

虽然有些运算符可以用于所有数据类型，但操作数是指定类型数据的话就更好了；并且大多数运算符返回（或计算出）的也是一个特定类型的值。比如逻辑非运算符 `!` 期望的操作数就是 `bool` 类型，如果不是，则会先将其转换为该类型。

### 左值

赋值及其它几个运算符期望的操作数是 `lval` 类型，表示该操作数（表达式）只能出现在赋值运算符的左侧。在 JavaScript 中，变量、对象属性和数组元素都是左值。

ES规范允许内置函数返回一个左值，但自定义函数则不能返回左值：只有内置函数才可以返回变量、对象属性或数组元素。

### 运算符的副作用

计算简单的表达式（比如 2*3）不会影响程序的运行状态，后续执行的状态也不会受影响。但有些表达式就会对程序有影响了，比如赋值运算符：给一个变量或属性赋值的话，后续使用这个变量或属性的表达式的值都会发生变化。自增和自减运算符也是这样，因为它们包含隐式的赋值。`delete` 运算符也是如此：删除一个属性就类似于（但不等于）给这个属性赋值 `undefined`。

其它的 JavaScript 运算符都没有副作用，除了函数调用表达式和对象创建表达式：在函数体或者构造函数内部运用了这些运算符并产生了副作用的时候，就说函数调用表达式和对象创建表达式是有副作用的（TODO: 也没太看懂……）。

### 运算符优先级

属性访问表达式和调用表达式的优先级要比所有其它运算符都高：

```javascript
typeof my.functions[x](y)
```

虽然 `typeof` 是优先级最高的运算符之一，但也是在属性访问和函数调用之后执行的。

最保险的保证优先级的方法，就是用圆括号来强行指定。

注意：乘法和除法的优先级高于加法和减法，赋值运算符的优先级非常低，通常总是最后执行的。

### 运算符的结合性

结合性：多个具有同样优先级的运算符表达式中的运算顺序。比如减法运算符具有从左至右的结合性，因此下面两行代码的执行效果是一样的：

```javascript
w = x - y - z;
w = ((x - y) - z);
```

### 运算顺序

运算符的优先级和结合性规定了它们在复杂的表达式中的运算顺序，但并没有规定子表达式在计算过程中的运算顺序 —— JavaScript 总是严格按照从左至右的顺序来计算表达式。

```javascript
w = x + y * z
```

比如在上面的表达式中，先依次计算表达式 w、x、y 和 z，然后计算 `y * z`，再计算 `x + y * z`，最后将其赋值给 w 所代表的变量或属性。

给表达式添加括号可以改变乘法、加法和赋值运算等运算符的关系，但从左至右计算子表达式的顺序是不会改变的。

只有在任一表达式具有副作用而影响到其它表达式的时候，其求值顺序才会和看上去有所不同。

```javascript
var a = 1;
var b = (a++)+a;
```

上面的表达式计算顺序是这样的：

1. 先计算子表达式 b 的值；
1. 计算 a++，子表达式的计算结果为 1，但是计算完成后 a 的值已经是 2 了；
1. 计算 a，值为 2；
1. 计算 (a++)+a，值为 3；
1. 将该表达式的结果 3 赋给 b。

## 算术表达式

基本的算术运算符：*（乘法）、/（除法）、%（取余）、+（加法）和 -（减法）。

加法之外的运算符都是在必要的时候将操作数转换为数字，然后求积、商、余数和差。无法转换为数字的操作数，都转换为 NaN。如果操作数是 NaN，算术运算的结果也是 NaN。

对于 JavaScript 来说，所有的数字都是浮点数，所以除法运算的结果总是浮点型。

取余运算符不限于整数，浮点数也可以，比如 `6.5 % 2.1 === 0.2（实际输出 0.19999999999999973）`。

### `+` 运算符

该运算符既可以将两个数字相加，也可以连接两个字符串。

一般来说，优先进行字符串连接。只要其中一个操作数是字符串或者转换为字符串的对象，另外一个操作数也会转换为字符串，然后加法运算符连接这两个字符串。

只有两个操作数都不是类字符串（string-like）的时候，才会进行算术加法运算。

加法运算符的表现如下：

1. 其中一个操作数是对象的话，就会遵循对象到原始值的转换规则进行转换：日期对象通过 `toString()` 方法转换，其它对象则通过 `valueOf()` 方法转换（如果 `valueOf()` 方法返回一个原始值的话）。因为大部分对象都没有可用的 `valueOf()` 方法，所以这些对象其实还是会通过 `toString()` 方法进行转换。
1. 对象转换到原始值后，如果其中一个操作数是字符串，则另一个操作数也会转换为字符串，然后加号运算符连接这两个字符串。
1. 两个操作数都不是对象的话，就会都转换为数字（或者 NaN），然后相加。

```javascript
1 + 2 // => 3: 加法
'1' + '2' // => '12': 字符串连接
'1' + 2 // => '12': 数字转换为字符串之后连接字符串
1 + {} // => '1[object Object]': 对象转换为字符串后连接字符串
true + true // => 2: 布尔值转换为数字后做加法
2 + null // => 2: null 转换为 0 之后做加法
2 + undefined // => NaN: undefined 转换为 NaN 之后做加法
```

另外，加号运算符和数字一起使用的时候，还要注意加法的结合性对运算顺序的影响。

```javascript
1 + 2 + ' blind mice' // => '3 blind mice'
1 + (2 + 'blind mice') // => '12blind mice'
```

### 一元算术运算符

一元运算符作用于一个操作数并产生一个新值。JavaScript 中的一元运算符都有很高的优先级，并且都是右结合。一元运算符在必要的时候会将操作数转换为数字。

一元加法（+）：该运算符把操作数转换为数字或者 NaN，并返回转换后的数字。如果操作数本身就是数字的话则直接返回（该运算符并不会改变操作数的正负号）。
一元减法（-）：该运算符根据需要把操作数转换为数字，然后改变运算结果的符号。

递增（++）：运算符将操作数（变量、数组元素或对象属性）转换为数字之后加 1，并将加 1 后的数值重新赋给变量、数组元素或对象属性。该运算符的返回值依赖于它相对于操作数的位置。运算符在操作数之前时，称为“前增量”，它将操作数加一之后，返回计算后的值。而运算符在操作数之后的话，称为“后增量”运算符，它对操作数进行加一运算，但返回的是加一之前的值。

```javascript
var i = 1, j = ++i; // => i: 2, j: 2
var i = 1, j = i++; // => i: 2, j: 1
```

这里还要注意区分 `++x` 和 `x = x + 1`：`++`运算符只执行数值运算操作，而 `+` 运算符有可能执行字符串连接操作。

```javascript
var x = '1'; ++x; // => 2
var x = '1'; x = x + 1; // => '11'
```

此外，由于 JavaScript 会自动进行分号补全，所以不能在后增量运算符和操作数之间插入换行符。如果插入了换行符，JavaScript 会把操作数当作一条单独的语句，并在其之前补上一个分号。

```javascript
var x = 1;
x
++ // => x: 1
```

递减（--）：与递增运算符相同。

### 位运算符

先 pass 这一小节。

## 关系表达式

关系运算符用于测试两个值之间的关系（比如“相等”、“小于”，或者“是……的属性”），并根据关系是否存在而返回 true 或者 false。

### 相等和不等运算符

`==` 和 `===` 运算符都用于比较两个值是否相等，都允许任意类型的操作数。

`===` 也称为“严格相等运算符”，

`!=` 和 `!==` 运算符是 `==` 和 `===` 运算符的求反：如果两个值通过 `==` 或 `===` 比较的结果为 true，则 `!=` 或 `!==` 的比较结果则为 false，反之亦然。

在 JavaScript 中，比较两个对象时，比较的是引用而不是值。对象只和它本身相等，和其它任何对象都不相等：即使具有相同数量的属性、相同的属性名和值也依然是不相等的。数组也是如此。

严格相等运算符 `===` 的比较流程如下：

- 如果两个值的类型不相等，则它们不相等。
- 如果两个值都是 null 或者 undefined ，则它们不相等。
- 如果两个值都是布尔值 true 或 false，则它们相等。
- 只要有一个值是 NaN，它们就不相等：NaN 和自身也不相等。所以可以用 `x !== x` 来判断是否为 NaN。
- 如果两个值为数字且相等，则它们相等。0 和 -0 也相等。
- 如果两个值为字符串，且各个对应位上的 16 位数完全相等，则它们相等。如果它们的长度或内容不同，则不相等。具有不同编码的 16 位值的两个字符串，所显示的字符可能是一样的。JavaScript 并不对 Unicode 进行标准化的转换，所以这样的字符通过 `===` 和 `==` 的比较结果也是不相等的。（TODO: 这里需要进一步了解，貌似有个有关特殊网址的 0day 漏洞应用的就是这个知识点？）
- 如果两个引用值均指向同一个对象、数组或函数，则它们相等。如果指向的是不同的对象，肯定不相等。

相等运算符 `==` 的判断就没那么严格了，如果两个操作数类型不同，相等运算符会先转换为相同类型，再进行比较：

- 如果两个操作数类型相同，则和上文所述的严格相等的比较规则和结果一样。
- 如果两个操作数类型不相同，则依据如下规则进行转换和比较：
  - 如果一个值是 null，另一个是 undefined，则它们相等。
  - 如果一个值是数字，另一个是字符串，则先将字符串转换为数字，然后比较两个数字。
  - 如果一个值是 true，则将其转换为 1 再进行比较；为 false 的话，则转换为 0 再进行比较。
  - 如果一个值是对象，另一个值是数字或字符串，则按照对象转换为原始值的规则，先将对象转换为原始值，再进行比较。JavaScript 语言核心的内置类中，只有对象使用 `toString()` 转换，其余类都是先尝试使用 `valueOf()` 转换，再尝试使用 `toString()` 转换。非核心的对象，则通过各自定义的方法转换为原始值。
  - 其它不同类型之间的比较均不相等。

以 `'1' == true` 为例：布尔值 true 首先转换为数字 1，然后字符串 '1' 也转换为数字 1，最后两个数字 1 相等，因此比较结果为 true。

### 比较运算符

虽然比较运算符的操作数可以是任意类型，但只有数字和字符串才能真正进行比较。其它类型的操作数的转换规则如下：

- 操作数为对象，则首先尝试用 `valueOf()` 转换成一个原始值，否则再用 `toString()` 的转换结果进行比较。
- 对象转换为原始值之后，如果两个操作数都是字符串，则依照字母表的顺序对两个字符串进行比较。这里的字母表顺序，是指组成字符串的 16 位 Unicode 字符的索引顺序。
- 对象转换为原始值之后，如果至少有一个操作数不是字符串，则两个操作数都转换为数字。0 和 -0 相等，Infinity 大于任何其它数（除了自己），-Infinity 小于任何其它数（除了自己）。如果其中一个操作数是（或者转换后是）NaN，则比较结果为 false。

注意：由于 JavaScript 字符串是由 16 位整数值组成的序列，所以字符串的比较就是这些数值的比较。而 Unicode 字符编码的顺序和传统字符编码顺序不太一样，其中所有大写的 ASCII 字母都“小于”小写字母。而 `String.localCompare()` 则使用本地语言的字母表中定义的字符次序进行比较，更符合用户习惯。

另外，对于数字和字符串来说，加号运算符和比较运算符也有所不同：加号运算符更偏爱字符串，至少有一个操作数是字符串，它就会进行字符串连接操作；比较运算符则更偏爱数字，只要有一个操作数是数字，它就进行数学加法操作。

```javascript
1 + 2 // => 3
'1' + '2' // => '12'
'1' + 2 // => '12'
11 < 3 // => false
'11' < '3' // => true
'11' < 3 // => false
'one' < 3 // => false
```

最后，`<=` 和 `>=` 则判断相等的时候，只是简单的“不大于”和“不小于”，并不依赖于相等运算符和严格相等运算符的比较规则。仅有一个例外：当其中一个操作数是（或者转换后是）NaN 的时候，所有 4 个比较运算符均返回 false。

### `in` 运算符

该运算符检查右侧的对象是否拥有一个名为左侧操作数的值的属性名，或者检查右侧的数组是否包含左侧的索引值。

```javascript
var point = { x: 1, y: 1 };
'x' in point // => true: 对象包含属性 x
'z' in point // => false: 对象不包含属性 z
'toString' in point // => true: 对象继承了 toString() 方法

var data = [7, 8, 9];
0 in data // => true: 数组包含索引为 0 的元素
'1' in data // => true: 数组包含索引为 1 的元素
3 in data // => false: 数组不包含索引为 3 的元素
7 in data // => false: 数组不包含索引为 7 的元素
```

### `instanceof` 运算符

该运算符检查左操作数对象是否为右操作数构造函数的实例。

```javascript
var d = new Date(); // => 通过 Date() 构造函数来新建一个对象
d instanceof Date; // => true: d 是由 Date() 构造函数创建的，所以是 Date 这个构造函数的实例
d instanceof Date(); // => VM224:1 Uncaught TypeError: Right-hand side of 'instanceof' is not an object
d instanceof Object; // => true: 所有的对象都是 Object 的实例
d instanceof Number; // => false
```

所有的对象都是 `Object` 的实例，而通过 `instanceof` 判断一个对象是否是一个类的实例的时候，这个判断也会包含对“父类”（superclass）的检测（TODO: 没太看懂……）。

`instanceof` 的左操作数不是对象的话，则返回 false；右操作数不是函数的话，就会抛出一个类型异常，看上面代码的第三就行。

要理解 `instanceof` 是如何工作的，必须首先理解“原型链”（prototype chain）——即 JavaScript 的继承机制。

计算表达式 `o instanceof f` 时，JavaScript 首先计算 `f.prototype`，然后在原型链中查找 `o`。如果能找到，则 `o` 是 `f`（或者 `f` 的父类）的一个实例，表达式返回 true；否则就说明 `o` 不是 `f` 的实例，表达式返回 false。

## 逻辑表达式

### 逻辑与（&&）运算符

该运算符可以对两个布尔值执行布尔与（AND）操作，也可以对真值和假值进行布尔与操作。在对真值/假值进行布尔与操作的时候，会先计算左操作数的值，只有左操作数为真值时，才会进一步计算右操作数。这个规则，也叫“短路”（short circuiting）。

### 逻辑或（||）运算符

该运算符也有类似的表现：如果左操作数为真，就不会再计算右操作数了。它的一种常用方式，是从一组备选表达式中选出第一个真值表达式：

```javascript
// 将 o 的成员属性复制到 p 中，并返回 p
function copy(o, p) {
    p = p || {}; // 如果未向参数 p 传入对象，则使用一个新建的空对象。
    // 函数体主逻辑
}
```

### 逻辑非（!）运算符

该运算符首先将操作数转换为布尔值，然后再对布尔值求反。结合这个特性，就可以用 `!!` 求出操作数的等价布尔值。

## 赋值表达式

其左操作数是一个左值：变量或者对象属性（或数组元素），右操作数可以是任意类型的任意值，且赋值表达式的值就是右操作数的值。

赋值操作符的结合性是从右至左，也就是说，下面的代码，先给 `k` 赋值，再给 `j` 赋值，最后给 `i` 赋值。

```javascript
i = j = k = 0;
```

### 带操作的赋值运算

下面的两个表达式是等价的：

```javascript
total += sales_tax
total = total + sales_tax
```

所有带操作的赋值运算：`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`>>>=`、`&=`、`|=`、`^=`。

```javascript
a op= b
a = a op b
```

在上面的两个表达式中，第一行的 `a` 只计算了一次，而第二行的 `a` 计算了两次。如果 `a` 有副作用，在使用该表达式的时候就需要注意一下。

## 表达式计算

TODO: 本小节暂时跳过。

## 其它运算符

### 条件运算符（?:）

该运算符常常可用来判断变量是否已定义，如果已定义则使用它，否则使用一个默认值：

```javascript
var greeting = 'hello ' + (username ? username : 'there');
```

### `typeof` 运算符

该运算符获取操作数的类型。

| x | typeof x |
| -- | -- |
| undefined | 'undefined' |
| null | 'object' |
| true / false | 'boolean' |
| 任意数字或 NaN | 'number' |
| 任意字符串 | 'string' |
| 任意函数 | 'function' |
| 任意内置对象（非函数） | 'object' |
| 任意宿主对象 | 由编译器各自实现的字符串，但不是 'undefined'、'boolean'、'number' 或者 'string'

常见用法：`(typeof value == 'string') ? '"' + value + '"' : value` 。

`typeof` 运算符也可以像函数一样带上圆括号，带不带括号，运行结果都是一样的。

另外，由于 `typeof null` 的返回结果也是 `object`，所以需要区分 `null` 和对象的时候，还要用 `!!value` 单独判断一下。

此外，客户端 JavaScript 中的大多数宿主对象都是 `object` 类型。

如果想进一步区分对象的类，就需要使用 `instanceof` 运算符、`class` 特性以及 `constructor` 属性。

### `delete` 运算符

该运算符用来删除对象的属性或者数组的元素。删除后的属性或者元素将不再存在，可以用 `in` 运算符来检查属性（名称）或者数组元素（索引）是否还存在。

```javascript
var o = { x: 1, y: 2 };
delete o.x; // => true: 成功删除属性
'x' in o; // => false: 属性不再存在
'y' in o; // => true: 该属性还存在

var a = [4, 5, 6];
delete a[2]; // => true: 成功删除元素
2 in a; // => false: 元素索引不再存在
1 in a; // => true: 该元素索引还存在
a.length // => 3: 数组长度未变！删除操作虽然删除了元素，但是并没有修改数组长度，所以该运算符在操作数组元素时要慎用。
```

如果 `delete` 的操作数不是左值，则运算符将不作任何操作并返回 true；否则，运算符将试图删除这个左值，成功的话返回 true。诸如内置核心属性、客户端属性、var 语句声明的属性、function 语句定义的函数和函数参数都不能删除。

在 ES5 严格模式中，如果 `delete` 的操作数是变量、函数参数或函数参数之类的非法操作数，则该操作将抛出一个语法错误（SyntaxError）异常；在删除不可配置的属性时，会抛出一个类型错误异常，只有操作数是属性访问表达式时才可删除。在非严格模式下，这些操作都不再报错，而只是简单地返回 false。

```javascript
var o = { x: 1, y: 2 };
delete o.x; // => true: 成功删除对象属性
typeof o.x; // => "undefined": 属性不再存在
delete o.x; // => true: 删除不存在的属性也返回 true
delete o; // => false: 不能删除 var 语句声明的变量
delete 1; // => true: 参数不是左值，删除失败，但也返回 true
this.x = 1; // => 1: 给全局对象定义一个属性
delete x; // => true: 非严格模式下可删除，严格模式下需改成 delete this.x
x // => 运行时错误，x 未定义
Uncaught ReferenceError: x is not defined
```

### `void` 运算符

一元运算符 `void` 可以出现在任意类型的操作数之前,操作数会照常计算，但表达式永远返回 undefined。由于 `void` 会忽略操作数，所以操作数有副作用的时候可以搭配该运算符使用。

该运算符常常用在客户端的 URL——javascript:URL 中，在 URL 可以放心地写带有副作用的表达式，`void` 则用来让浏览器不显示表达式的计算结果。

```javascript
<a href="javascript:void window.open();">打开一个新窗口</a>
```

但是在实际开发中其实不会这么写，而是给该节点的 `onclick` 绑定一个事件处理程序。

### 逗号运算符（,）

逗号运算符是二元运算符，它依次计算左操作数和右操作数的值，然后返回右操作数的值。该运算符最常用的场景在 `for` 循环中：

```javascript
for ( var i = 0, j = 10; i < j; i++, j--) {
    console.log(i + j);
}
```

# 语句

在 JavaScript 中，表达式是短语，语句（statement）就是整句或者命令。表达式只是计算出一个值，只有语句才能用来执行以让某件事发生。

本质上，JavaScript 程序就是一些以分号分隔的语句的集合。只要掌握了语句，就可以开始编写程序了。

## 表达式语句

具有副作用的表达式是 JavaScript 中最简单的语句：包括赋值语句、`delete` 语句、函数调用语句。

## 复合语句和空语句

逗号运算符用于将几个表达式连接成一个表达式，而花括号则可以将几条语句联合成一条复合语句（compound statement）。

**注意**：

1. 语句块的结尾不需要分号，只有块内的原始语句才需要。
1. 为了代码便于阅读，建议语句尽使用缩进。
1. JavaScript 中没有块级作用域，语句块中声明的变量不是语句块私有的。

空语句则只有一个引号，有时它还是有用的：

```javascript
// 初始化数组a
for (var i = 0; i < a.length; a[i++] = 0) ;
```

这样就不需要在循环体里再写语句了，多方便。不过出于特殊目的需要使用空语句的时候，最好在代码中添加注释，便于理解。

## 声明语句

### `var`

`var` 语句用来声明至少一个变量：

```javascript
var name_1 [= value_1] [, ... , name_n [= value_n]];
```

声明多个变量时，用逗号分隔的变量可以独占一行。

```javascript
var x = 2,
    f = function(x) { return x * x; },
    y = f(x);
```

声明的变量如果没有赋值，则变量的值为 undefined。由于 JavaScript 声明提前特性的存在，脚本或函数中定义的变量，声明语句其实都会被“提前”至脚本或函数的顶部，但是初始化操作还是在原来的位置上执行的。

### `function`

前面讲过了函数定义表达式，函数定义还可以写成语句的形式。

```javascript
var f = function(x) { return x + 1; }
function f(x) { return x + 1; }
```

上面两种写法定义的函数，用起来是一样的（TODO: 是否完全一样？还需要研究一下）。

定义函数时，并不会执行函数体里的语句，这些语句只和调用函数时待执行的新函数对象相关联。

注意：function 语句里的花括号是必需的，即使只有一条语句也是如此。

如果函数内还嵌套了函数，则内部嵌套的函数，其定义不能出现在 `if` 语句、`while` 循环或任何其它语句中，只能出现在所嵌套函数的顶部（TODO: 没太看懂……为什么不能出现？）。由于函数声明位置的这种限制，ES 规范因此并没有将函数声明归类为真正的语句。

函数声明语句和函数定义表达式的区别：

- 函数声明语句中的函数名是一个变量名，变量指向函数对象。和通过 `var` 声明的变量一样，函数声明语句中的函数（函数名及函数体）被显式地“提前”到了脚本或函数的顶部，因此它们在整个脚本或函数里都是可见的。
- 用 `var` 声明的函数定义表达式，只有变量声明被提前了，变量初始化的代码还在原来的位置上。相比而言，脚本或函数里的函数声明语句会在所有代码之前执行。这样的话，可以在函数声明之前就调用它了。

函数声明语句创建的变量和 `var` 语句创建的变量一样，都是无法删除的。但是函数声明语句创建的这些变量不是只读的，可以被重写。

## 条件语句

和其它语言的基本一样，只列出几个关键点。

对于 `switch` 语句，关键字 `switch` 里的表达式和 `case` 子句中的表达式在比较的时候，用的是 `===` 这个严格相等运算符来比较的，不会做任何类型转换，这一点要注意。

另外，`switch` 语句中的 `case` 表达式是在运行时计算的，从而导致该语句的效率会比较低。

## 循环

`for` 循环的工作流程，可以用一个等价的 `while` 循环来理解：

```javascript
initialize;
while(test) {
    statement
    increment;
}
// 等价于
for(initialize; test; increment) { statement; }
```

下面的 `for` 循环活用里空语句来遍历链表数据结构，并返回链表中最后一个对象（即第一个不包含 `next` 属性的对象）：

```javascript
function tail(o) {
    for (; o.next; o = o.next) /* empty */ ;
    return o;
}
```

`for` 循环适合用于遍历数组元素，而 `for/in` 循环则适合用于遍历对象属性成员（通过属性名来遍历）：

```javascript
for (var p in o) {
    console.log(o[p]);
}
```

该循环的执行流程：

```javascript
for (variable in object)
    statement
```

1. JavaScript 解释器首先计算 `object` 表达式，表达式如果为 null 或者 undefined，则解释器会跳过循环并执行后续的代码。
1. 如果表达式等于一个原始值，则原始值会被转换为与之对应的包装对象。
1. 否则表达式本身就是一个对象，则以此枚举对象的属性来执行循环。
1. 在每次循环之前，JavaScript 都会先计算 `variable` 表达式的值，并将属性名（字符串）赋给它。

注意：`for/in` 循环中，`variable` 的值只要可以当作赋值表达式左值，就可以是任意表达式。比如下面这段代码将对象的所有属性名称复制到一个数组中：

```javascript
var o = { x: 1, y: 2, z: 3 };
var a = [], i = 0;
for ( a[i++] in o) /* empty */;
```

因为 JavaScript 中的数组本质上也是对象，所以 `for/in` 循环可以像枚举对象的属性一样，枚举数组的索引。接着上面的代码，可以枚举数组的索引：

```javascript
for ( i in a ) console.log(i);
```

还要注意，`for/in` 循环并不会遍历对象的所有属性，只会遍历“可枚举”（enumerable）的属性。JavaScript 语言核心部分所定义的内置方法就不可枚举，比如 `toString()` 方法。而在代码中用户自定义的所有属性和方法都是可枚举的（除了通过特殊手段设置的属性）。从其他自定义对象继承而来的自定义属性也是可以用 `for/in` 枚举出来的。

如果在 `for/in` 循环中删除了一个还未被枚举的属性，则该属性将不再被枚举。如果在 `for/in` 循环中定义了新属性，这些属性**通常**也不会被枚举。

### 属性枚举的顺序

TODO: 暂时先不深入该知识点。

主流浏览器厂商实际上是按照属性定义的先后顺序来枚举**简单**对象的属性的。如果用直接量创建对象，则按照直接量中属性出现的顺序来枚举。

而对于下面的情况，枚举的顺序则取决于具体的实现（并且还是非交互的）：

- 对象继承了可枚举属性；
- 对象具有整数数组索引的属性；
- 使用 `delete` 删除了对象已有的属性；
- 使用 `Object.defineProperty()` 或者类似的方法改变了对象的属性。

## 跳转

### 标签语句

JavaScript 中，语句也是可以加标签的，用做标签的标识符必须是合法的，不能是保留字。

```javascript
identifier: statement
```

由于标签的命名空间和变量或函数的命名空间是不同的，所以语句标签和变量名或函数名可以同名。

语句标签只在它起作用的语句内有定义。两个互不嵌套的代码段里的语句标签可以同名，和它内部的语句标签则不能同名。

一条语句可以有多个标签。

给语句定义标签之后，就可以在程序的任何地方通过标签名引用该语句。虽然也可以给多条语句定义标签，但只有在给语句块定义标签时才更有用。

通过给循环定义一个标签，可以在循环体内部使用 `break` 和 `continue` 来退出循环，或者直接跳到下一个循环的开始处。`break` 和 `continue` 是 JavaScript 中仅有的可以使用标签的语句。

### `break` 语句

单独使用 `break` 会立即退出最内层循环或 `switch` 语句：`break;`。

`break` 和标签一起使用时，程序将跳转到这个标签所标识的语句块的结束处，或者直接终止闭合语句块的执行。由于 `break` 本身就能直接退出循环或 `switch` 语句，因此如果要和标签一起使用的话，标签应该标识的是由花括号括起来的一组语句。

```javascript
var matrix = getDate(); // 从某处获取一个二维数组
// 对矩阵所有元素求和
// 从标签名开始，以便报错时退出程序
compute_sum: if (matrix) {
    for (var x = 0; x < matrix.length; x++) {
        var row = matrix[x];
        if (!row) break compute_sum;
        for (var y = 0; y < row.length; y++) {
            var cell = row[y];
            if (isNaN(cell)) break compute_sum;
            sum += cell;
        }
    }
    success = true;
}
// break 语句跳转至此
// 如果在 success == false 的条件下到达这里，说明给出的矩阵中有错误
// 否则将矩阵中所有的元素进行求和
```

最后还要注意：`break` 语句的控制权无法越过函数边界，即不能从函数内部跳转到函数外部。

### `continue` 语句

`continue` 语句直接执行下一次循环。在 `for` 循环中，首先计算自增表达式，然后检测 `test` 表达式，用以判断是否执行循环体。

与 `break` 语句不同的是，`continue` 语句只能在循环体内使用。

### `return` 语句

`return` 语句指定函数调用后的返回值，它只能在函数体内出现，否则就会报语法错误。执行到该语句时，函数就会停止执行，并返回其右侧的表达式（如果有的话）的值给调用程序。

### `throw` 语句

在 JavaScript 中产生运行时错误或程序使用 `throw` 语句时都会显式抛出异常。该语句的表达式可以是任意类型，但解释器抛出异常时通常采用 Error 类型或其子类型。

一个 Error 对象包含：表示错误类型的 `name` 属性，存放传递给构造函数的字符串的 `message` 属性。

- 抛出异常时，JavaScript 解释器会立即执行当前正在执行的逻辑，并跳转至就近的异常处理程序。
- 如果抛出异常的代码块没有相关联的 `catch` 从句，解释器会检查更高层的闭合代码块，直到找到异常处理程序为止。
- 如果抛出异常的函数没有一个 `try/catch/finally` 语句来处理它，则异常将向上传播至调用该函数的代码。这样异常就会沿着方法的词法结构和调用栈向上传播。
- 如果最后都没有找到任何异常处理程序，JavaScript 就会把异常当成程序错误来处理，并报告给用户。

### `try/catch/finally` 语句

需要处理异常的代码块位于 `try` 从句中，`catch` 从句跟随在 `try` 从句之后，处理 `try` 从句中的异常。最后跟着 `finally` 从句，放置清理代码，这里的代码总是会被执行到，只要 `try` 从句中有一部分代码执行了。

`catch` 和 `finally` 至少要存在一个，并且三个从句里的代码块都要用花括号括起来。

如果 `return`、`continue`、`break` 或者 `throw` 语句使 `finally` 块发生了跳转，或者它调用了会抛出异常的方法使其发生了跳转，解释器都会忽略所挂起的跳转，而去执行新的跳转（TODO: 后面的例子能看懂，但是这里的文字不太懂……）。比如 `finally` 从句如果抛出了异常，则该异常会代替之前正在处理的异常。如果 `finally` 从句运行到了 `return` 语句，则该方法会正常返回，之前所抛出且未处理的异常将不会被处理。

```javascript
try {
  try {
    throw new SyntaxError();
  } catch (ex) {
    ;
  } finally {
    throw new RangeError();
  }
} catch (ex) {
  console.info(ex.name);
} finally {
  console.info('cleaned');
}
// => RangeError
// => cleaned
```

## 其它语句类型

### `with` 语句

`with` 语句用于临时扩展作用域链，它将对象添加到作用域链头部，执行语句之后，再把作用域链恢复到原始状态。

```javascript
with (object)
    statement
```

由于使用 `with` 语句的代码很难优化，并且运行速度也慢，所以非严格模式里不推荐使用，严格模式更是禁止使用。

对象嵌套层次很深的时候，可以用 `with` 来简化代码。下面第一行的表达式如果则代码中多次出现，则可以用后面的 `with` 语句将 `form` 对象添加至作用域链的顶层：

```javascript
document.forms[0].address.value;
with (document.forms[0]) {
    // 直接访问表单元素：
    name.value = "";
    address.value = "";
    email.value = "";
}
```

注意：只有在查找标识符的时候才会用到作用域链，创建新变量的时候是用不着的：

```javascript
with (o) x = 1;
```

对于上面的代码，如果对象 `o` 有属性 `x`，则将会赋值 1；否则就是在当前作用域内新建变量 `x` 并赋值 1。

### `debugger` 语句

在调试程序的时候，该语句可以让代码停在当前位置。比如调用函数 `f()` 时使用了未定义的参数，函数抛出异常，但无法定位是哪里抛出了异常，这个时候就可以利用 `debugger` 了：

```javascript
function f(o) {
    if (o == undefined) debugger; // 用于临时调试
    ... // 函数的其它部分
}
```

### "use strict"

这是 ES5 引入的一条指令，它和普通的语句有两个重要区别：

- 它不包含任何关键字。
- 它只能出现在脚本代码的开始处或者函数体的开始处，或者任意实体语句之前。但它不必非得出现在脚本或函数体的首行。

该指令说明后续的代码将会解析为严格代码（strict code）。严格模式和非严格模式之间的区别仅列出最重要的前三条：

- 严格模式中禁止使用 `with` 语句。
- 严格模式中，所有的变量都要先声明再赋值，如果未声明就赋值，将会抛出引用错误异常（在非严格模式中，这种写法会给全局对象添加新属性）。
- 严格模式中，调用的函数（不包括方法）中的 `this` 的值是 undefined（在非严格模式中，调用的函数中的 `this` 的值总是全局对象）。可以利用这种特性来判断当前是否支持严格模式：

```javascript
var hasStrictMode = (function() { "use strict"; return this === undefined; }());
```

# 对象

## 创建对象

### 对象直接量

对象的属性名可以是标识符也可以是字符串直接量（空字符串也可以），属性的值可以是任意类型的表达式，表达式的值就是属性的值。

```javascript
var empty = {}; // 没有任何属性的空对象
var point = { x: 1, y: 1 }; // 两个属性
var point2 = { x: point.x, y: point.y+1 }; // 更复杂的值
var book = {
    "main title": "JavaScript", // 属性名有空格，必须用字符串表示
    "sub-title": "The Definitive Guide", // 属性名有连字符，必须用字符串表示
    "for": "all audiences", // "for"是保留字，必须用引号
    "author": { // 该属性的值是一个对象
        firstname: "David", // 这里的属性名都没有引号
        surname: "Flanagan"
    }
};
```

对象直接量是表达式，这个表达式的每次运算都会创建并初始化一个新的对象。每次计算对象直接量时，也都会计算它的每个属性的值。因此，**如果在一个重复调用的函数中的循环体内使用了对象直接量，它将创建很多新对象，并且每次创建的对象的属性值也有可能不同。**

### 通过 `new` 创建新对象

关键字 `new` 的后面跟随一个函数调用，用来创建并初始化新对象。这里的函数为构造函数，语言核心中的原始类型都包含构造函数。也可以用自定义的构造函数来初始化新对象。

```javascript
var o = new Object(); // 创建一个空对象，和 {} 一样
var a = new Array(); // 创建一个空数组，和 [] 一样
var d = new Date(); // 创建一个表示当前时间的 Date 对象
var r = new RegExp("js"); // 创建一个可以进行模式匹配的 RegExp 对象
```

### 原型

TODO: 没太看明白……

在 JavaScript 中，每个对象（除了 null）都和另一个对象相关联——另一个对象就是原型。每个对象都从原型继承属性。

通过对象直接量创建的所有对象具有共同的原型对象，并且可以通过 `Object.prototype` 获得对原型对象的引用。通过关键字 `new` 及构造函数所创建的对象，其原型就是构造函数的 `prototype` 属性的值。所以 `new Object()` 所创建的对象也继承自 `Object.prototype`，`new Array()` 创建的对象其原型就是 `Array.prototype`。

只有少数对象没有原型，包括 `Object.prototype`，它不继承任何属性。其他的原型对象都是普通对象，普通对象都有原型。所有的内置构造函数以及大部分自定义的构造函数，都有一个继承自 `Object.prototype` 的原型，比如 `Date.prototype` 的属性就继承自 `Object.prototype`。因此，由 `new Date()` 创建的 Date 对象的属性，同时继承自 `Date.prototype` 和 `Object.prototype`，这一系列链接起来的原型对象就是所谓的“原型链”（prototype chain）。

### `Object.create()`

ES5 中定义了该方法用于创建对象。第一个参数为对象的原型，第二个可选参数用于进一步描述对象的属性。

`Object.create()` 是一个静态函数，也就是说它不能被某个对象作为方法调用：

```javascript
var o1 = Object.create({x:1, y:2}); // o1 继承了属性 x 和 y
```

可以传入参数 null 来创建一个没有原型的对象，这个对象不会继承任何东西，包括 `toString()` 这样的基础方法。

```javascript
var o2 = Object.create(null); // 不继承任何属性和方法，在浏览器中输入o2，然后再输入一个点号的话，不会有任何自动完成的提示
```

如果想创建一个普通的空对象（就像 `{}` 或者 `new Object()` 创建的对象），要传入参数 `Object.prototype`：

```javascript
var o3 = Object.create(Object.prototype); // 和 {} 及 new Object() 一样
```

还可以通过任意原型创建新对象（也就是可以使任意对象可继承），下面的代码就模拟了原型继承：

```javascript
// TODO: 没太看明白……
function inherit(p) {
    if (p == null) throw TypeError(); // p必须是非null的对象
    if (Object.create) return Object.create(p); // 该方法存在时，则直接使用
    var t = typeof p; // 否则进一步检测
    if (t !== "object" && t !== "function") throw TypeError();
    function f() {}; // 定义空构造函数
    f.prototype = p; // 令其原型为 p
    return new f(); // 用 f() 创建 p 的继承对象
}
```

上面创建的 `inherit()` 函数，作用之一就是防止库函数无意间修改了不受控制的对象。该方法不是直接将对象作为参数传入函数，而是将目标对象的继承对象传给函数（令返回的对象的原型为传入的对象）。这样函数在读取继承对象属性的时候，读取的就是继承过来的值。在给继承对象的属性赋值的时候，就只影响继承对象自身，不会影响原始对象了：

```javascript
var o1 = { x: 1 };
var o2 = inherit(o1);
o2.x = 2;
o2.x // => 2
o1.x // => 1: o2 继承自 o1，修改 o2 的属性 x，没有影响 o1 中的同名属性
```

## 属性的查询和设置

在 JavaScript 中，可以通过点号（`.`）或者方括号（`[]`）来获取或者设置属性的值：

```javascript
var author = book.author; // 获取 book 的 "author" 属性
var title = book["main title"]; // 获取 book 的 "main title" 属性
book.edition = 6; // 设置 book 的 edition 属性
book["main title"] = "ECMAScript"; // 设置 book 的 "main title" 属性
```

使用点运算符时，右侧必须是以属性名称命名的简单标识符；对于方括号来说，方括号内必须是一个计算结果为字符串（或是一个可以转换为字符串的值）的表达式。

### 作为关联数组的对象

上面讲到的两种属性查询方法都能够查询对象属性的值，方括号的形式看起来更像数组，只是这个“数组”——对象的元素是通过字符串索引的，这种数组就叫关联数组（associative array）。

在一些强类型语言中（如C、C++、Java等），对象的属性都是提前定义好的，无法动态增删。而 JavaScript 由于是弱类型语言，因此可以在任何对象中创建任意数量的属性。通过点号 `.` 访问对象属性时，属性名称为标识符，而标识符不是数据类型，因此无法修改。

而用方括号 `[]` 来访问对象属性时，此时的属性名为字符串，字符串又是 JavaScript 的数据类型，所以在程序运行时可以修改或创建它们。假设要给 `portfolio` 这个对象动态添加新的属性——股票，就可以用 `[]` 运算符来实现：

function addstock(portfolio, stockname, shares) {
    portfolio[stockname] = shares;
}

再结合 `for/in` 循环，就可以很方便地遍历关联数组（对象）了：

```javascript
function getValue(portfolio) {
    var total = 0.0;
    for (stock in portfolio) { // 遍历 portfolio 中的每只股票
        var shares = portfolio[stock]; // 获取每只股票的份额
        var price = getQuote(stock); // 查找股票价格
        total += shares * price; // 将结果累加至 total 中
    }
    return total; // 返回 total 的值
}
```

### 继承

JavaScript 中的对象，既有自有属性（own property），也有从原型对象继承来的属性。在查询对象 o 的属性 x 时，如果 o 中不存在 x，就会继续在 o 的原型对象中查询属性 x。如果原型对象也没有 x，但这个原型对象还有原型，就会继续在这个原型对象的原型中查询，直到找到 x 或者找到原型为 null 的对象为止。对象及其原型构成了一个“链条”，通过这个链条就实现了属性的继承。

```javascript
var o = {}; // o 通过这种形式从 Object.prototype 继承对象
o.x = 1; // 给 o 定义属性 x
var p = inherit(o); // p 继承 o 和 Object.prototype
p.y = 2; // 给 p 定义属性 y
var q = inherit(p); // q 继承 p、o 和 Object.prototype
q.x = 3; // 给 q 定义同名属性 x
var s = q.toString(); // toString 继承自 Object.prototype
q.x + q.y; // => 3: x 用的是 q 中的自有属性，y 则继承自对象 p
```

假设现在要给对象 o 的属性 x 赋值，如果 o 中已经有了自有属性 x，则赋值操作就只改变这个自有属性的值。如果 o 中不存在属性 x，则赋值操作就给 o 添加一个新属性 x 并赋值。如果 o 的原型对象中有属性 x，那么在 o 中新建的属性 x 就会覆盖原型对象中的同名属性。

给属性赋值时，首先会检查原型链，确认是否允许赋值。如果 o 继承自一个只读属性 x，则赋值操作是不允许的。如果允许赋值，也总是在原始对象上创建属性或对已有的属性赋值，并不会修改原型链——不会修改原型对象中的同名属性。因此，只有在查询属性时才能体会到继承的存在，设置属性就和继承无关了，这样可以让程序员选择性地覆盖（override）继承的属性。

```javascript
var unitcircle = { r: 1 }; // 用于继承的对象
var c = inherit(unitcircle); // c 继承了属性 r
c.x = 1; c.y = 1; // c 新定义两个属性
c.r = 2; // c 覆盖了继承来的属性
unitcircle.r; // => 1: 原型对象未被修改
```

给属性赋值，有几种可能的结果：要么失败，要么创建一个属性，要么在原始对象中设置属性（TODO: 是指修改原始对象现有属性的值？），只有一种例外：如果 o 继承了属性 x，而属性 x 是一个具有 `setter` 方法的 `accessor` 属性，这时将调用 `setter` 方法，而不会给 o 创建属性 x。注意：调用 `setter` 方法的将是 o，而不是定义这个属性的原型对象；因此，如果 `setter` 方法定义了属性的话，这个定义属性的操作是作用在 o 上的，而不是去修改原型链。

### 属性访问错误

本节讲讲查询或设置属性时，一些出错的情况。

先讲讲查询属性：查询不存在的属性时不会报错，在对象的原型链上查找属性而该属性不存在时，就返回 undefined。

```javascript
book.subtitle; // => undefined: 属性不存在
```

但是，查询不存在的对象的属性时，就会报错了。null 和 undefined 都没有属性，所以查询它俩的属性就会报错：

```javascript
var len = book.subtitle.length;
// 抛出一个类型错误异常，说 undefined 没有 length 属性
// => TypeError: Cannot read property 'length' of undefined
```

为了避免出错，可以像下面这两种方法这样查询属性：

```javascript
// 第一种方法有些罗嗦，但容易看懂
var len = undefined;
if (book) {
    if (book.subtitle) len = book.subtitle.length;
}

// 第二种方法则比较简练
var len = book && book.subtitle && book.subtitle.length;
```

再讲讲设置属性：给 null 和 undefined 设置属性肯定会报类型错误，给只读属性设置值也会报错；但还有些不允许新增属性的对象，对其设置属性时，失败了却不会报错：

```javascript
// 内置构造函数的原型是只读的
Object.prototype = 0; // 赋值失败，但没有报错，Object.prototype 没有被修改
```

这是个历史遗留问题，在 ES5 的严格模式中已经修复了。在严格模式中，任何失败的属性设置操作都会抛出一个类型错误异常。

给对象 o 设置属性 p 会失败的场景总结如下（TODO: 这些先记下来，回头用的时候再弄清楚）：

- o 中的属性 p 是只读的：不能给只读属性重新赋值（`defineProperty()` 方法中有个例外，可以对可配置的只读属性重新赋值）。
- o 中的属性 p 是继承属性，且是只读的：不能通过同名自有属性覆盖只读的继承属性。
- o 中不存在自有属性：o 没有使用 setter 方法继承属性 p，并且 o 的可扩展性（entensible attribute）为 false。如果 o 中不存在 p，并且没有 setter 方法可供调用，则 p 一定会添加至 o 中。但如果 o 是不可扩展的，在 o 中就不能定义新属性了。
